<haxe>
	<class path="neko.Lib" params="" file="/usr/share/haxe/std/neko/Lib.hx">
		<load public="1" set="method" line="32" static="1">
			<f a="lib:prim:nargs">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<d/>
			</f>
			<haxe_doc>Load and return a Neko primitive from a NDLL library.</haxe_doc>
		</load>
		<loadLazy public="1" set="method" line="36" static="1"><f a="lib:prim:nargs">
	<c path="String"/>
	<c path="String"/>
	<c path="Int"/>
	<d/>
</f></loadLazy>
		<print public="1" set="method" line="47" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output.</haxe_doc>
		</print>
		<println public="1" set="method" line="54" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print the specified value on the default output followed by a newline character.</haxe_doc>
		</println>
		<rethrow public="1" set="method" line="62" static="1">
			<f a="e">
				<d/>
				<d/>
			</f>
			<haxe_doc>Rethrow an exception. This is useful when manually filtering an exception in order
		to keep the previous exception stack.</haxe_doc>
		</rethrow>
		<serialize public="1" set="method" line="70" static="1">
			<f a="v">
				<d/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Serialize using native Neko serialization. This will return a Binary string that can be
		stored for long term usage. The serialized data is optimized for speed and not for size.</haxe_doc>
		</serialize>
		<unserialize public="1" set="method" line="77" static="1">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<d/>
			</f>
			<haxe_doc>Unserialize a string using native Neko serialization. See [serialize].</haxe_doc>
		</unserialize>
		<localUnserialize public="1" set="method" line="88" static="1">
			<f a="s">
				<c path="haxe.io.Bytes"/>
				<d/>
			</f>
			<haxe_doc>Unserialize a string using native Neko serialization. See [serialize].
		This function assume that all the serialized data was serialized with current
		module, even if the module name was different. This can happen if you are unserializing
		some data into mod_neko that was serialized on a different server using a different
		file path.</haxe_doc>
		</localUnserialize>
		<nekoToHaxe public="1" set="method" line="98" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>Converts a Neko value to its haXe equivalent. Used for wrapping String and Arrays raw values into haXe Objects.</haxe_doc>
		</nekoToHaxe>
		<haxeToNeko public="1" set="method" line="130" static="1">
			<f a="v">
				<d/>
				<d/>
			</f>
			<haxe_doc>Converts a Neko value to its haXe equivalent. Used to unwrap String and Arrays Objects into raw Neko values.</haxe_doc>
		</haxeToNeko>
		<getClasses public="1" set="method" line="165" static="1">
			<f a=""><d/></f>
			<haxe_doc>Returns an object containing all compiled packages and classes.</haxe_doc>
		</getClasses>
		<stringReference public="1" get="inline" set="null" line="172" static="1">
			<f a="b">
				<c path="haxe.io.Bytes"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string referencing the data contains in bytes.</haxe_doc>
		</stringReference>
		<bytesReference public="1" get="inline" set="null" line="179" static="1">
			<f a="s">
				<c path="String"/>
				<c path="haxe.io.Bytes"/>
			</f>
			<haxe_doc>Returns bytes referencing the content of a string.</haxe_doc>
		</bytesReference>
		<__serialize line="183" static="1"><f a="">
	<d/>
	<t path="haxe.io.BytesData"/>
</f></__serialize>
		<__unserialize line="184" static="1"><f a=":">
	<t path="haxe.io.BytesData"/>
	<a>
		<loadprim><f a="p:n">
	<unknown/>
	<unknown/>
	<unknown/>
</f></loadprim>
		<loadmodule><f a="m:l">
	<unknown/>
	<unknown/>
	<unknown/>
</f></loadmodule>
	</a>
	<unknown/>
</f></__unserialize>
	</class>
	<class path="Array" params="T" file="/usr/share/haxe/std/neko/_std/Array.hx">
		<new1 params="T" set="method" line="36" static="1"><f a="a:l">
	<c path="neko.NativeArray"><c path="new1.T"/></c>
	<c path="Int"/>
	<c path="Array"><c path="new1.T"/></c>
</f></new1>
		<__neko set="method" line="280"><f a=""><c path="neko.NativeArray"><c path="Array.T"/></c></f></__neko>
		<__double set="method" line="265"><f a="l">
	<c path="Int"/>
	<e path="Void"/>
</f></__double>
		<__set set="method" line="250"><f a="pos:v">
	<c path="Int"/>
	<c path="Array.T"/>
	<c path="Array.T"/>
</f></__set>
		<__get set="method" line="246"><f a="pos">
	<c path="Int"/>
	<c path="Array.T"/>
</f></__get>
		<splice public="1" set="method" line="219">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Removes [len] elements starting from [pos] an returns them.</haxe_doc>
		</splice>
		<sort public="1" set="method" line="196">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].]]></haxe_doc>
		</sort>
		<slice public="1" set="method" line="179">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.</haxe_doc>
		</slice>
		<shift public="1" set="method" line="166">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element and returns it.</haxe_doc>
		</shift>
		<reverse public="1" set="method" line="152">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Reverse the order of elements of the Array.</haxe_doc>
		</reverse>
		<remove public="1" set="method" line="135">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.</haxe_doc>
		</remove>
		<unshift public="1" set="method" line="127">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the element [x] at the start of the array.</haxe_doc>
		</unshift>
		<push public="1" set="method" line="120">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Adds the element [x] at the end of the array.</haxe_doc>
		</push>
		<pop public="1" set="method" line="111">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of the array and returns it.</haxe_doc>
		</pop>
		<toString public="1" set="method" line="98">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the Array content.</haxe_doc>
		</toString>
		<join public="1" set="method" line="86">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of an array with [sep] for separating each element.</haxe_doc>
		</join>
		<insert public="1" set="method" line="73">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.</haxe_doc>
		</insert>
		<iterator public="1" set="method" line="58">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method" line="54">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a copy of the Array. The values are not
		copied, only the Array structure.</haxe_doc>
		</copy>
		<concat public="1" set="method" line="43">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending [a] to [this].</haxe_doc>
		</concat>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The length of the Array</haxe_doc>
		</length>
		<__a><c path="neko.NativeArray"><c path="Array.T"/></c></__a>
		<new public="1" set="method" line="31">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
		<meta>
			<m n=":core_api"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="Class" params="T" file="/usr/share/haxe/std/Class.hx" extern="1"><haxe_doc>An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Date" params="" file="/usr/share/haxe/std/neko/_std/Date.hx">
		<now public="1" set="method" line="72" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" line="76" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" line="84" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.</haxe_doc>
		</fromString>
		<new1 set="method" line="88" static="1"><f a="t">
	<d/>
	<c path="Date"/>
</f></new1>
		<date_new line="94" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></date_new>
		<date_now line="95" static="1"><f a=""><unknown/></f></date_now>
		<date_format line="96" static="1"><f a=":">
	<d/>
	<unknown/>
	<c path="String"/>
</f></date_format>
		<date_set_hour line="97" static="1"><f a=":::">
	<d/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></date_set_hour>
		<date_set_day line="98" static="1"><f a=":::">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></date_set_day>
		<date_get_day line="99" static="1"><f a="">
	<d/>
	<a>
		<y><c path="Int"/></y>
		<m><c path="Int"/></m>
		<d><c path="Int"/></d>
	</a>
</f></date_get_day>
		<date_get_hour line="100" static="1"><f a="">
	<d/>
	<a>
		<s><c path="Int"/></s>
		<m><c path="Int"/></m>
		<h><c path="Int"/></h>
	</a>
</f></date_get_hour>
		<int32_to_float line="101" static="1"><f a="">
	<d/>
	<c path="Int"/>
</f></int32_to_float>
		<int32_add line="102" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></int32_add>
		<int32_shl line="103" static="1"><f a=":">
	<unknown/>
	<c path="Int"/>
	<unknown/>
</f></int32_shl>
		<__string set="method" line="104" static="1"><f a=""><c path="String"/></f></__string>
		<toString public="1" set="method" line="68">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method" line="64">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the week day of the date (0-6 range).</haxe_doc>
		</getDay>
		<getSeconds public="1" set="method" line="60">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the seconds of the date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method" line="56">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the minutes value of the date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method" line="52">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the hours value of the date (0-23 range).</haxe_doc>
		</getHours>
		<getDate public="1" set="method" line="48">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the day of the date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method" line="44">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the month of the date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method" line="40">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Returns the full year of the date.</haxe_doc>
		</getFullYear>
		<getTime public="1" set="method" line="36">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.</haxe_doc>
		</getTime>
		<__t><d/></__t>
		<new public="1" set="method" line="31">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new date object.</haxe_doc>
		</new>
		<haxe_doc>The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.</haxe_doc>
		<meta>
			<m n=":core_api"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="EReg" params="" file="/usr/share/haxe/std/neko/_std/EReg.hx">
		<regexp_new_options line="157" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></regexp_new_options>
		<regexp_match line="158" static="1"><f a=":::">
	<d/>
	<unknown/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></regexp_match>
		<regexp_matched line="159" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<c path="String"/>
</f></regexp_matched>
		<regexp_matched_pos line="160" static="1"><f a=":">
	<d/>
	<c path="Int"/>
	<a>
		<pos><c path="Int"/></pos>
		<len><c path="Int"/></len>
	</a>
</f></regexp_matched_pos>
		<customReplace public="1" set="method" line="144">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.</haxe_doc>
		</customReplace>
		<replace public="1" set="method" line="93">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.</haxe_doc>
		</replace>
		<split public="1" set="method" line="69">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split a string by using the regular expression to match
		the separators.</haxe_doc>
		</split>
		<matchedPos public="1" set="method" line="65">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position of the matched substring within the
		original matched string.</haxe_doc>
		</matchedPos>
		<matchedRight public="1" set="method" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was at the right of
		of the matched substring.</haxe_doc>
		</matchedRight>
		<matchedLeft public="1" set="method" line="54">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part of the string that was as the left of
		of the matched substring.</haxe_doc>
		</matchedLeft>
		<matched public="1" set="method" line="49">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.</haxe_doc>
		</matched>
		<match public="1" set="method" line="40">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the regular expression matches the String.
		Updates the internal state accordingly.</haxe_doc>
		</match>
		<global><e path="Bool"/></global>
		<last><c path="String"/></last>
		<r><d/></r>
		<new public="1" set="method" line="32">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern [r] and
		options [opt].</haxe_doc>
		</new>
		<haxe_doc>Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.</haxe_doc>
		<meta>
			<m n=":core_api"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="Enum" params="T" file="/usr/share/haxe/std/Enum.hx" extern="1"><haxe_doc>An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="EnumValue" params="" file="/usr/share/haxe/std/EnumValue.hx" extern="1"><haxe_doc>An abstract type that represents any enum value.
	See [Type] for the haXe Reflection API.</haxe_doc></class>
	<class path="Hash" params="T" file="/usr/share/haxe/std/neko/_std/Hash.hx">
		<toString public="1" set="method" line="62">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an displayable representation of the hashtable content.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="56">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>Returns an iterator of all values in the hashtable.</haxe_doc>
		</iterator>
		<keys public="1" set="method" line="50">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>Returns an iterator of all keys in the hashtable.</haxe_doc>
		</keys>
		<remove public="1" get="inline" set="null" line="46">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Removes a hashtable entry. Returns [true] if
		there was such entry.</haxe_doc>
		</remove>
		<exists public="1" get="inline" set="null" line="42">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.</haxe_doc>
		</exists>
		<get public="1" get="inline" set="null" line="38">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>Get a value for the given key.</haxe_doc>
		</get>
		<set public="1" get="inline" set="null" line="34">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set a value for the given key.</haxe_doc>
		</set>
		<h><d/></h>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty hashtable.</haxe_doc>
		</new>
		<haxe_doc>Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="IntIter" params="" file="/usr/share/haxe/std/IntIter.hx">
		<next public="1" set="method" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>Moves to the next item of the iterator.</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Returns true if the iterator has other items, false otherwise.</haxe_doc>
		</hasNext>
		<max><c path="Int"/></max>
		<min><c path="Int"/></min>
		<new public="1" set="method" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.]]></haxe_doc>
		</new>
		<haxe_doc>Integer iterator. Used for interval implementation.</haxe_doc>
	</class>
	<class path="Lambda" params="" file="/usr/share/haxe/std/Lambda.hx">
		<array public="1" params="A" set="method" line="35" static="1">
			<f a="it">
				<t path="Iterable"><c path="array.A"/></t>
				<c path="Array"><c path="array.A"/></c>
			</f>
			<haxe_doc>Creates an [Array] from an [Iterable]</haxe_doc>
		</array>
		<list public="1" params="A" set="method" line="45" static="1">
			<f a="it">
				<t path="Iterable"><c path="list.A"/></t>
				<c path="List"><c path="list.A"/></c>
			</f>
			<haxe_doc>Creates a [List] from an [Iterable]</haxe_doc>
		</list>
		<map public="1" params="A:B" set="method" line="56" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="map.A"/></t>
				<f a="">
					<c path="map.A"/>
					<c path="map.B"/>
				</f>
				<c path="List"><c path="map.B"/></c>
			</f>
			<haxe_doc>Creates a new [Iterable] by appling the function 'f' to all
		elements of the iterator 'it'.</haxe_doc>
		</map>
		<mapi public="1" params="A:B" set="method" line="66" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="mapi.A"/></t>
				<f a=":">
					<c path="Int"/>
					<c path="mapi.A"/>
					<c path="mapi.B"/>
				</f>
				<c path="List"><c path="mapi.B"/></c>
			</f>
			<haxe_doc>Similar to [map], but also pass an index for each item iterated.</haxe_doc>
		</mapi>
		<has public="1" params="A" set="method" line="81" static="1">
			<f a="it:elt:?cmp">
				<t path="Iterable"><c path="has.A"/></t>
				<c path="has.A"/>
				<f a=":">
					<c path="has.A"/>
					<c path="has.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the element is part of an iterable. The comparison
		is made using the [==] operator. Optionally you can pass as
		a third parameter a function that performs the comparison.
		That function must take as arguments the two items to
		compare and returns a boolean value.</haxe_doc>
		</has>
		<exists public="1" params="A" set="method" line="97" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="exists.A"/></t>
				<f a="">
					<c path="exists.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if at least one element of the iterable is found by using the specific function.</haxe_doc>
		</exists>
		<foreach public="1" params="A" set="method" line="107" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="foreach.A"/></t>
				<f a="">
					<c path="foreach.A"/>
					<e path="Bool"/>
				</f>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if all elements of the iterable have the specified property defined by [f].</haxe_doc>
		</foreach>
		<iter public="1" params="A" set="method" line="117" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="iter.A"/></t>
				<f a="">
					<c path="iter.A"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>Call the function 'f' on all elements of the [Iterable] 'it'.</haxe_doc>
		</iter>
		<filter public="1" params="A" set="method" line="125" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Return the list of elements matching the function 'f'</haxe_doc>
		</filter>
		<fold public="1" params="A:B" set="method" line="136" static="1">
			<f a="it:f:first">
				<t path="Iterable"><c path="fold.A"/></t>
				<f a=":">
					<c path="fold.A"/>
					<c path="fold.B"/>
					<c path="fold.B"/>
				</f>
				<c path="fold.B"/>
				<c path="fold.B"/>
			</f>
			<haxe_doc>Functional 'fold' using an [Iterable]</haxe_doc>
		</fold>
		<count public="1" params="A" set="method" line="145" static="1">
			<f a="it:?pred">
				<t path="Iterable"><c path="count.A"/></t>
				<f a="">
					<c path="count.A"/>
					<e path="Bool"/>
				</f>
				<c path="Int"/>
			</f>
			<haxe_doc>Count the number of elements in an [Iterable] having [pred] returning true.</haxe_doc>
		</count>
		<empty public="1" set="method" line="160" static="1">
			<f a="it">
				<t path="Iterable"><d/></t>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an iterable does not contain any element.</haxe_doc>
		</empty>
		<indexOf public="1" params="T" set="method" line="168" static="1">
			<f a="it:v">
				<t path="Iterable"><c path="indexOf.T"/></t>
				<c path="indexOf.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the item in the given Iterable, depending on the order of the Iterator.
		Returns -1 if the item was not found.</haxe_doc>
		</indexOf>
		<concat public="1" params="T" set="method" line="181" static="1">
			<f a="a:b">
				<t path="Iterable"><c path="concat.T"/></t>
				<t path="Iterable"><c path="concat.T"/></t>
				<c path="List"><c path="concat.T"/></c>
			</f>
			<haxe_doc>Returns a list containing all items of 'a' followed by all items of 'b'</haxe_doc>
		</concat>
		<haxe_doc>The [Lambda] class is a collection of functional methods in order to
	use functional-style programming with haXe.</haxe_doc>
	</class>
	<class path="List" params="T" file="/usr/share/haxe/std/List.hx">
		<map public="1" params="X" set="method" line="246">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>Returns a new list where all elements have been converted
		by the function [f].</haxe_doc>
		</map>
		<filter public="1" set="method" line="230">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].</haxe_doc>
		</filter>
		<join public="1" set="method" line="211">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Join the element of the list by using the separator [sep].</haxe_doc>
		</join>
		<toString public="1" set="method" line="191">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a displayable representation of the String.</haxe_doc>
		</toString>
		<iterator public="1" set="method" line="152">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<remove public="1" set="method" line="129">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.</haxe_doc>
		</remove>
		<clear public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Makes the list empty.</haxe_doc>
		</clear>
		<isEmpty public="1" set="method" line="112">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>Tells if a list is empty.</haxe_doc>
		</isEmpty>
		<pop public="1" set="method" line="98">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.</haxe_doc>
		</pop>
		<last public="1" set="method" line="88">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the last element of the list, or null
		if the list is empty.</haxe_doc>
		</last>
		<first public="1" set="method" line="80">
			<f a=""><t path="Null"><c path="List.T"/></t></f>
			<haxe_doc>Returns the first element of the list, or null
		if the list is empty.</haxe_doc>
		</first>
		<push public="1" set="method" line="64">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Push an element at the beginning of the list.</haxe_doc>
		</push>
		<add public="1" set="method" line="51">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Add an element at the end of the list.</haxe_doc>
		</add>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of elements in this list.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="44">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.</haxe_doc>
	</class>
	<class path="Math" params="" file="/usr/share/haxe/std/neko/_std/Math.hx">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<min public="1" set="method" line="34" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" set="method" line="35" static="1"><f a="a:b">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<abs public="1" set="method" line="37" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<sin public="1" set="method" line="38" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" set="method" line="39" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" set="method" line="40" static="1"><f a="y:x">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" set="method" line="41" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" set="method" line="42" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" set="method" line="43" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" set="method" line="44" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" set="method" line="45" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" set="method" line="46" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" set="method" line="47" static="1"><f a="v">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" set="method" line="48" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" set="method" line="49" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" set="method" line="50" static="1"><f a="v">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" set="method" line="51" static="1"><f a="v:exp">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<__rnd static="1"><unknown/></__rnd>
		<_rand_float line="54" static="1"><f a="">
	<unknown/>
	<c path="Float"/>
</f></_rand_float>
		<_rand_int line="55" static="1"><f a=":">
	<unknown/>
	<c path="Int"/>
	<unknown/>
</f></_rand_int>
		<random public="1" set="method" line="57" static="1"><f a=""><c path="Float"/></f></random>
		<isNaN public="1" set="method" line="59" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<isFinite public="1" set="method" line="60" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
		<meta>
			<m n=":core_api"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="Random" params="" file="src/Random.hx">
		<bool public="1" get="inline" set="null" line="3" static="1"><f a=""><e path="Bool"/></f></bool>
		<int public="1" get="inline" set="null" line="8" static="1"><f a="from:to">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></int>
		<float public="1" get="inline" set="null" line="13" static="1"><f a="from:to">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></float>
		<fromArray public="1" params="T" get="inline" set="null" line="18" static="1"><f a="arr">
	<c path="Array"><c path="fromArray.T"/></c>
	<t path="Null"><c path="fromArray.T"/></t>
</f></fromArray>
	</class>
	<class path="RandomTest" params="" file="test/RandomTest.hx">
		<arrayNull public="1" set="method" line="196">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</arrayNull>
		<arrayEmpty public="1" set="method" line="189">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</arrayEmpty>
		<arrayOfInts public="1" set="method" line="169">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</arrayOfInts>
		<arrayOfStrings public="1" set="method" line="149">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</arrayOfStrings>
		<bool public="1" set="method" line="138">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</bool>
		<floatInclusive public="1" set="method" line="131">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</floatInclusive>
		<floatDecimal public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</floatDecimal>
		<floatNegativeAndPositive public="1" set="method" line="107">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</floatNegativeAndPositive>
		<floatNegative public="1" set="method" line="95">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</floatNegative>
		<float public="1" set="method" line="83">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</float>
		<intInclusive public="1" set="method" line="76">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</intInclusive>
		<intNegativeAndPositive public="1" set="method" line="64">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</intNegativeAndPositive>
		<intNegative public="1" set="method" line="52">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</intNegative>
		<int public="1" set="method" line="40">
			<f a=""><e path="Void"/></f>
			<meta><m n="Test"/></meta>
		</int>
		<tearDown public="1" set="method" line="34">
			<f a=""><e path="Void"/></f>
			<meta><m n="After"/></meta>
		</tearDown>
		<setup public="1" set="method" line="29">
			<f a=""><e path="Void"/></f>
			<meta><m n="Before"/></meta>
		</setup>
		<afterClass public="1" set="method" line="24">
			<f a=""><e path="Void"/></f>
			<meta><m n="AfterClass"/></meta>
		</afterClass>
		<beforeClass public="1" set="method" line="19">
			<f a=""><e path="Void"/></f>
			<meta><m n="BeforeClass"/></meta>
		</beforeClass>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Auto generated ExampleTest for MassiveUnit. 
* This is an example test class can be used as a template for writing normal and async tests 
* Refer to munit command line tool for more information (haxelib run munit)</haxe_doc>
	</class>
	<class path="Reflect" params="" file="/usr/share/haxe/std/neko/_std/Reflect.hx">
		<hasField public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if an object has a field set. This doesn't take into account the object prototype (class methods).</haxe_doc>
		</hasField>
		<field public="1" get="inline" set="null" line="32" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the field of an object, or null if [o] is not an object or doesn't have this field.</haxe_doc>
		</field>
		<setField public="1" get="inline" set="null" line="36" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set an object field value.</haxe_doc>
		</setField>
		<getProperty public="1" get="inline" set="null" line="41" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Similar to field but also supports property (might be slower).</haxe_doc>
		</getProperty>
		<setProperty public="1" get="inline" set="null" line="46" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Similar to setField but also supports property (might be slower).</haxe_doc>
		</setProperty>
		<callMethod public="1" get="inline" set="null" line="53" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method with the given object and arguments.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" line="57" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of fields of an object, excluding its prototype (class methods).</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="72" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is a function or not.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" get="inline" set="null" line="76" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Generic comparison function, does not work for methods, see [compareMethods]</haxe_doc>
		</compare>
		<compareMethods public="1" get="inline" set="null" line="80" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Compare two methods closures. Returns true if it's the same method of the same instance.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" line="84" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if a value is an object or not.</haxe_doc>
		</isObject>
		<deleteField public="1" get="inline" set="null" line="88" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Delete an object field.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" get="inline" set="null" line="92" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>Make a copy of the fields of an object.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" line="96" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
		</makeVarArgs>
		<same_closure line="101" static="1"><f a=":">
	<d/>
	<d/>
	<e path="Bool"/>
</f></same_closure>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="Float" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>The standard Float type, this is a double-precision IEEE 64bit float.</haxe_doc></class>
	<class path="Int" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>The standard Int type. Its precision depends on the platform.</haxe_doc>
	</class>
	<enum path="Bool" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>The standard Boolean type is represented as an enum with two choices.</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.</haxe_doc></class>
	<enum path="Void" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>The standard Void type. Only [null] values can be of the type [Void].</haxe_doc></enum>
	<class path="neko.Boot" params="" file="/usr/share/haxe/std/neko/Boot.hx">
		<__tmp_str set="method" line="30" static="1"><f a=""><c path="String"/></f></__tmp_str>
		<__enum_str set="method" line="34" static="1"><f a="e">
	<d/>
	<c path="String"/>
</f></__enum_str>
		<__interfLoop set="method" line="56" static="1"><f a="cc:cl">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__interfLoop>
		<__instanceof set="method" line="72" static="1">
			<f a="o:cl">
				<a>
					<__name__ set="null"><unknown/></__name__>
					<__enum__ set="null"><t path="#Dynamic"/></__enum__>
					<__ename__ set="null"><unknown/></__ename__>
					<__class__ set="null"><unknown/></__class__>
				</a>
				<t path="#Dynamic"/>
				<e path="Bool"/>
			</f>
			<meta><m n=":feature"><e>typed_catch</e></m></meta>
		</__instanceof>
		<__serialize set="method" line="90" static="1"><f a="o">
	<a>
		<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><c path="Int"/></length></a></__ename__></a></__enum__>
		<__class__ set="null"><a><__name__ set="null"><a><length set="null"><c path="Int"/></length></a></__name__></a></__class__>
	</a>
	<c path="Array"><unknown/></c>
</f></__serialize>
		<__tagserialize set="method" line="110" static="1"><f a="o">
	<a>
		<tag set="null"><unknown/></tag>
		<__enum__ set="null"><a><__ename__ set="null"><a><length set="null"><c path="Int"/></length></a></__ename__></a></__enum__>
	</a>
	<c path="Array"><unknown/></c>
</f></__tagserialize>
		<__unserialize set="method" line="119" static="1"><f a="v">
	<c path="Array"><unknown/></c>
	<unknown/>
</f></__unserialize>
		<__init set="method" line="142" static="1"><f a=""><e path="Void"/></f></__init>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="Std" params="" file="/usr/share/haxe/std/neko/_std/Std.hx">
		<is public="1" set="method" line="29" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<meta><m n=":feature"><e>typed_cast</e></m></meta>
			<haxe_doc>Tells if a value v is of the type t.</haxe_doc>
		</is>
		<string public="1" set="method" line="33" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Convert any value to a String</haxe_doc>
		</string>
		<int public="1" set="method" line="37" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Convert a Float to an Int, rounded down.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="42" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" line="53" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>Convert a String to a Float, parsing different possible reprensations.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" line="60" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 0 included and x excluded.</haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<typedef path="Null" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<typedef path="Iterator" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method"><f a=""><c path="Iterator.T"/></f></next>
			<hasNext set="method"><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/share/haxe/std/neko/_std/String.hx">
		<__is_String static="1"><e path="Bool"/></__is_String>
		<__split line="29" static="1"><d/></__split>
		<fromCharCode public="1" set="method" line="204" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<__radd set="method" line="200"><f a="s">
	<d/>
	<c path="String"/>
</f></__radd>
		<__add set="method" line="196"><f a="s">
	<d/>
	<c path="String"/>
</f></__add>
		<__compare set="method" line="192"><f a="o">
	<c path="String"/>
	<c path="Int"/>
</f></__compare>
		<toString public="1" set="method" line="186">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<toUpperCase public="1" set="method" line="170">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been uppercased.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method" line="154">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns an String where all characters have been lowercased.</haxe_doc>
		</toLowerCase>
		<substring public="1" set="method" line="130">
			<f a="startIndex:?endIndex">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Returns a part of the String, taking from [startIndex] to [endIndex] - 1.
		If [endIndex] is not specified, length is used.
		If [startIndex] or [endIndex] is smaller than 0, than 0 is used.
		If [startIndex] > [endIndex] then they are swaped.]]></haxe_doc>
		</substring>
		<substr public="1" set="method" line="104">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.</haxe_doc>
		</substr>
		<split public="1" set="method" line="88">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Split the string using the specified delimiter.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method" line="73">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Similar to [indexOf] but returns the latest index.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method" line="64">
			<f a="str:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method" line="58">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at the given position.
		Returns [null] if outside of String bounds.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method" line="46">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at the given position.
		Returns the empty String if outside of String bounds.</haxe_doc>
		</charAt>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>The number of characters in the String.</haxe_doc>
		</length>
		<new public="1" set="method" line="37">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.</haxe_doc>
		<meta>
			<m n=":core_api"/>
			<m n=":final"/>
		</meta>
	</class>
	<class path="StringBuf" params="" file="/usr/share/haxe/std/neko/_std/StringBuf.hx">
		<__make line="50" static="1"><d/></__make>
		<__add line="51" static="1"><d/></__add>
		<__add_char line="52" static="1"><d/></__add_char>
		<__add_sub line="53" static="1"><d/></__add_sub>
		<__string line="54" static="1"><d/></__string>
		<toString public="1" get="inline" set="null" line="46">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of the string buffer.
		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<addChar public="1" get="inline" set="null" line="42">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a part of a string to the string buffer.</haxe_doc>
		</addChar>
		<addSub public="1" get="inline" set="null" line="38">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds a character to the string buffer.</haxe_doc>
		</addSub>
		<add public="1" get="inline" set="null" line="34">
			<f a="x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Adds the representation of any value to the string buffer.</haxe_doc>
		</add>
		<b><d/></b>
		<new public="1" set="method" line="30">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new string buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by
	appending small elements together.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="StringTools" params="" file="/usr/share/haxe/std/StringTools.hx">
		<urlEncode public="1" set="method" line="41" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode an URL by using the standard format.</haxe_doc>
		</urlEncode>
		<urlDecode public="1" set="method" line="68" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Decode an URL using the standard format.</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" set="method" line="95" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape HTML special characters of the string.</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" set="method" line="102" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Unescape HTML special characters of the string.</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" set="method" line="113" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] starts with the string [start].</haxe_doc>
		</startsWith>
		<endsWith public="1" set="method" line="126" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the string [s] ends with the string [end].</haxe_doc>
		</endsWith>
		<isSpace public="1" set="method" line="141" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Tells if the character in the string [s] at position [pos] is a space.</haxe_doc>
		</isSpace>
		<ltrim public="1" set="method" line="149" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the left of the String [s].</haxe_doc>
		</ltrim>
		<rtrim public="1" set="method" line="170" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the right of the String [s].</haxe_doc>
		</rtrim>
		<trim public="1" set="method" line="192" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Removes spaces at the beginning and the end of the String [s].</haxe_doc>
		</trim>
		<rpad public="1" set="method" line="207" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its right until it reach [l] characters.</haxe_doc>
		</rpad>
		<lpad public="1" set="method" line="229" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Pad the string [s] by appending [c] at its left until it reach [l] characters.</haxe_doc>
		</lpad>
		<replace public="1" set="method" line="254" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurences of the string [sub] in the string [s] by the string [by].</haxe_doc>
		</replace>
		<hex public="1" set="method" line="269" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.</haxe_doc>
		</hex>
		<fastCodeAt public="1" get="inline" set="null" line="292" static="1">
			<f a="s:index">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Provides a fast native string charCodeAt access. Since the EOF value might vary depending on the platforms, always test with StringTools.isEOF.
		Only guaranteed to work if index in [0,s.length] range. Might not work with strings containing \0 char.</haxe_doc>
		</fastCodeAt>
		<isEOF public="1" get="inline" set="null" line="322" static="1"><f a="c">
	<c path="Int"/>
	<e path="Bool"/>
</f></isEOF>
		<_urlEncode line="341" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></_urlEncode>
		<_urlDecode line="342" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></_urlDecode>
		<haxe_doc>The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.</haxe_doc>
	</class>
	<class path="Sys" params="" file="/usr/share/haxe/std/neko/_std/Sys.hx">
		<print public="1" set="method" line="28" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output.</haxe_doc>
		</print>
		<println public="1" set="method" line="32" static="1">
			<f a="v">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Print any value on the standard output, followed by a newline</haxe_doc>
		</println>
		<getChar public="1" set="method" line="36" static="1">
			<f a="echo">
				<e path="Bool"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Read a single input character from the standard input (without blocking) and returns it. Setting [echo] to true will also display it on the output.</haxe_doc>
		</getChar>
		<stdin public="1" set="method" line="40" static="1">
			<f a=""><c path="haxe.io.Input"/></f>
			<haxe_doc>Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See [getChar] for an alternative.</haxe_doc>
		</stdin>
		<stdout public="1" set="method" line="44" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard output on which you can write.</haxe_doc>
		</stdout>
		<stderr public="1" set="method" line="48" static="1">
			<f a=""><c path="haxe.io.Output"/></f>
			<haxe_doc>Returns the process standard error on which you can write.</haxe_doc>
		</stderr>
		<args public="1" set="method" line="52" static="1">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>Returns all the arguments that were passed by the commandline.</haxe_doc>
		</args>
		<getEnv public="1" set="method" line="67" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the given environment variable.</haxe_doc>
		</getEnv>
		<putEnv public="1" set="method" line="74" static="1">
			<f a="s:v">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Set the value of the given environment variable.</haxe_doc>
		</putEnv>
		<sleep public="1" set="method" line="78" static="1">
			<f a="seconds">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Suspend the current execution for the given time (in seconds).</haxe_doc>
		</sleep>
		<setTimeLocale public="1" set="method" line="82" static="1">
			<f a="loc">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Change the current time locale, which will affect [DateTools.format] date formating.
		Returns true if the locale was successfully changed</haxe_doc>
		</setTimeLocale>
		<getCwd public="1" set="method" line="86" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Get the current working directory (usually the one in which the program was started)</haxe_doc>
		</getCwd>
		<setCwd public="1" set="method" line="90" static="1">
			<f a="s">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Change the current working directory.</haxe_doc>
		</setCwd>
		<systemName public="1" set="method" line="94" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the system you are running on. For instance :
			"Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.</haxe_doc>
		</systemName>
		<escapeArgument set="method" line="98" static="1"><f a="arg">
	<c path="String"/>
	<c path="String"/>
</f></escapeArgument>
		<command public="1" set="method" line="112" static="1">
			<f a="cmd:?args">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
				<c path="Int"/>
			</f>
			<haxe_doc>Run the given command with the list of arguments. The command output will be printed on the same output as the current process.
		The current process will block until the command terminates and it will return the command result (0 if there was no error).
		Read the [sys.io.Process] api for a more complete way to start background processes.</haxe_doc>
		</command>
		<exit public="1" set="method" line="121" static="1">
			<f a="code">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Exit the current process with the given error code.</haxe_doc>
		</exit>
		<time public="1" set="method" line="125" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds).</haxe_doc>
		</time>
		<cpuTime public="1" set="method" line="129" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.</haxe_doc>
		</cpuTime>
		<executablePath public="1" set="method" line="133" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the path to the current executable that we are running.</haxe_doc>
		</executablePath>
		<environment public="1" set="method" line="137" static="1">
			<f a=""><c path="Hash"><c path="String"/></c></f>
			<haxe_doc>Returns the whole environement variables.</haxe_doc>
		</environment>
		<get_env line="147" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></get_env>
		<put_env line="148" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<unknown/>
</f></put_env>
		<_sleep line="149" static="1"><f a="">
	<c path="Float"/>
	<unknown/>
</f></_sleep>
		<set_time_locale line="150" static="1"><f a="">
	<unknown/>
	<e path="Bool"/>
</f></set_time_locale>
		<get_cwd line="151" static="1"><f a=""><c path="String"/></f></get_cwd>
		<set_cwd line="152" static="1"><f a="">
	<unknown/>
	<unknown/>
</f></set_cwd>
		<sys_string line="153" static="1"><f a=""><c path="String"/></f></sys_string>
		<sys_command line="154" static="1"><f a="">
	<unknown/>
	<c path="Int"/>
</f></sys_command>
		<sys_exit line="155" static="1"><f a="">
	<c path="Int"/>
	<unknown/>
</f></sys_exit>
		<sys_time line="156" static="1"><f a=""><c path="Float"/></f></sys_time>
		<sys_cpu_time line="157" static="1"><f a=""><c path="Float"/></f></sys_cpu_time>
		<sys_exe_path line="158" static="1"><f a=""><c path="String"/></f></sys_exe_path>
		<sys_env line="159" static="1"><f a=""><c path="Array"><d/></c></f></sys_env>
		<file_stdin line="161" static="1"><f a=""><e path="sys.io.FileHandle"/></f></file_stdin>
		<file_stdout line="162" static="1"><f a=""><e path="sys.io.FileHandle"/></f></file_stdout>
		<file_stderr line="163" static="1"><f a=""><e path="sys.io.FileHandle"/></f></file_stderr>
		<getch line="164" static="1"><f a="">
	<e path="Bool"/>
	<c path="Int"/>
</f></getch>
		<haxe_doc>This class gives you access to many base functionalities of system platforms. Looks in [sys] sub packages for more system APIs.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="TestMain" params="" file="test/TestMain.hx">
		<main set="method" line="19" static="1"><f a=""><e path="Void"/></f></main>
		<completionHandler set="method" line="46"><f a="successful">
	<e path="Bool"/>
	<e path="Void"/>
</f></completionHandler>
		<new public="1" set="method" line="21"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Auto generated Test Application.
 * Refer to munit command line tool for more information (haxelib run munit)</haxe_doc>
	</class>
	<class path="massive.munit.TestSuite" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/TestSuite.hx">
		<sortByName set="method" line="120"><f a="x:y">
	<c path="Class"><d/></c>
	<c path="Class"><d/></c>
	<c path="Int"/>
</f></sortByName>
		<sortTests set="method" line="115"><f a=""><e path="Void"/></f></sortTests>
		<repeat public="1" set="method" line="110">
			<f a=""><e path="Void"/></f>
			<haxe_doc><![CDATA[* Drop the iterator back one so next call to <code>next()</code> will return the
	 * same test class again.]]></haxe_doc>
		</repeat>
		<next public="1" set="method" line="101">
			<f a=""><c path="Class"><d/></c></f>
			<haxe_doc>* Get the next test class in this iterable suite of test classes.
	 * 
	 * @return	the next test class in the suite, or null if no more classes available</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="91">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check to see if there is another test class in this iterable suite of test classes.
	 * 
	 * @return	true if there is another test class, false if not</haxe_doc>
		</hasNext>
		<add public="1" set="method" line="80">
			<f a="test">
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add a class which contains test methods.
	 * 
	 * @param	test			a class containing methods which execute tests</haxe_doc>
		</add>
		<index><c path="Int"/></index>
		<tests><c path="Array"><d/></c></tests>
		<new public="1" set="method" line="69">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Class constructor.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Iterable (http://haxe.org/ref/iterators) suite of test classes.
 * <p>
 * Each class added to a test suite should contain one or more meta tagged methods which execute unit tests.
 * </p>
 * <pre>
 * class MathUtilTest
 * {
 *     @Test
 *     public function testAdd():Void
 *     {
 *         Assert.areEqual(2, MathUtil.add(1,1));
 *     }
 * }
 * 
 * class TestSuite extends massive.unit.TestSuite
 * {
 *     public function new()
 *     {
 *          add(MathUtilTest);
 *     }
 * }
 * </pre>
 * @author Mike Stead]]></haxe_doc>
	</class>
	<class path="TestSuite" params="" file="test/TestSuite.hx">
		<extends path="massive.munit.TestSuite"/>
		<new public="1" set="method" line="13"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Auto generated Test Suite for MassiveUnit.
 * Refer to munit command line tool for more information (haxelib run munit)</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/share/haxe/std/neko/_std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"><d/></c></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
	</enum>
	<class path="Type" params="" file="/usr/share/haxe/std/neko/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>Returns the class of a value or [null] if this value is not a Class instance.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" line="49" static="1">
			<f a="o">
				<c path="EnumValue"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Returns the enum of a value or [null] if this value is not an Enum instance.</haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" line="56" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Returns the super-class of a class, or null if no super class.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="61" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of a class.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" line="68" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the complete name of an enum.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" line="73" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>Evaluates a class from a name. The class must have been compiled
		to be accessible.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" line="88" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"><d/></c>
			</f>
			<haxe_doc>Evaluates an enum from a name. The enum must have been compiled
		to be accessible.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" line="102" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of the given class with the list of constructor arguments.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="106" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" line="112" static="1">
			<f a="e:constr:?params">
				<c path="Enum"><c path="createEnum.T"/></c>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor name and parameters.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" line="124" static="1">
			<f a="e:index:?params">
				<c path="Enum"><c path="createEnumIndex.T"/></c>
				<c path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Create an instance of an enum by using a constructor index and parameters.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" line="130" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of instance fields.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" line="147" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the list of a class static fields.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" line="163" static="1">
			<f a="e">
				<c path="Enum"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns all the available constructor names for an enum.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" line="168" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of a value.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="190" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>Recursively compare two enums constructors and parameters.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" line="205" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor of an enum</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" line="209" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns the parameters of an enum</haxe_doc>
		</enumParameters>
		<enumIndex public="1" get="inline" set="null" line="213" static="1">
			<f a="e">
				<c path="EnumValue"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Returns the index of the constructor of an enum</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" line="217" static="1">
			<f a="e">
				<c path="Enum"><c path="allEnums.T"/></c>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns the list of all enum values that don't take any parameter.</haxe_doc>
		</allEnums>
		<haxe_doc>The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<typedef path="haxe._Http.AbstractSocket" params="" file="/usr/share/haxe/std/haxe/Http.hx" private="1" module="haxe.Http"><a>
	<write set="method"><f a="str">
	<c path="String"/>
	<e path="Void"/>
</f></write>
	<shutdown set="method"><f a="read:write">
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></shutdown>
	<setTimeout set="method"><f a="t">
	<c path="Float"/>
	<e path="Void"/>
</f></setTimeout>
	<output set="null"><c path="haxe.io.Output"/></output>
	<input set="null"><c path="haxe.io.Input"/></input>
	<connect set="method"><f a="host:port">
	<c path="sys.net.Host"/>
	<c path="Int"/>
	<e path="Void"/>
</f></connect>
	<close set="method"><f a=""><e path="Void"/></f></close>
</a></typedef>
	<class path="haxe.Http" params="" file="/usr/share/haxe/std/haxe/Http.hx">
		<PROXY public="1" line="62" static="1"><a>
	<port><c path="Int"/></port>
	<host><c path="String"/></host>
	<auth><a>
	<user><c path="String"/></user>
	<pass><c path="String"/></pass>
</a></auth>
</a></PROXY>
		<requestUrl public="1" set="method" line="633" static="1"><f a="url">
	<c path="String"/>
	<c path="String"/>
</f></requestUrl>
		<onStatus public="1" set="dynamic" line="629"><f a="status">
	<c path="Int"/>
	<e path="Void"/>
</f></onStatus>
		<onError public="1" set="dynamic" line="626"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></onError>
		<onData public="1" set="dynamic" line="623"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></onData>
		<readChunk set="method" line="564"><f a="chunk_re:api:buf:len">
	<c path="EReg"/>
	<c path="haxe.io.Output"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></readChunk>
		<readHttpResponse set="method" line="425"><f a="api:sock">
	<c path="haxe.io.Output"/>
	<t path="haxe._Http.AbstractSocket"/>
	<e path="Void"/>
</f></readHttpResponse>
		<customRequest public="1" set="method" line="269"><f a="post:api:?sock:?method">
	<e path="Bool"/>
	<c path="haxe.io.Output"/>
	<t path="haxe._Http.AbstractSocket"/>
	<c path="String"/>
	<e path="Void"/>
</f></customRequest>
		<fileTransfert public="1" set="method" line="265"><f a="argname:filename:file:size">
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></fileTransfert>
		<request public="1" set="method" line="98"><f a="post">
	<e path="Bool"/>
	<e path="Void"/>
</f></request>
		<setPostData public="1" set="method" line="91"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></setPostData>
		<setParameter public="1" set="method" line="87"><f a="param:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setParameter>
		<setHeader public="1" set="method" line="83"><f a="header:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setHeader>
		<params><c path="Hash"><c path="String"/></c></params>
		<headers><c path="Hash"><c path="String"/></c></headers>
		<postData><c path="String"/></postData>
		<file><a>
	<size><c path="Int"/></size>
	<param><c path="String"/></param>
	<io><c path="haxe.io.Input"/></io>
	<filename><c path="String"/></filename>
</a></file>
		<chunk_buf><c path="haxe.io.Bytes"/></chunk_buf>
		<chunk_size><t path="Null"><c path="Int"/></t></chunk_size>
		<responseHeaders public="1"><c path="Hash"><c path="String"/></c></responseHeaders>
		<cnxTimeout public="1"><c path="Float"/></cnxTimeout>
		<noShutdown public="1"><e path="Bool"/></noShutdown>
		<url public="1"><c path="String"/></url>
		<new public="1" set="method" line="69">
			<f a="url">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* In PHP Https (SSL) connections are allowed only if the OpenSSL extension is enabled.
	 * @param	url</haxe_doc>
		</new>
	</class>
	<class path="haxe.Int32" params="" file="/usr/share/haxe/std/neko/_std/haxe/Int32.hx">
		<make public="1" get="inline" set="null" line="29" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" get="inline" set="null" line="33" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<toInt public="1" get="inline" set="null" line="37" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<toNativeInt public="1" get="inline" set="null" line="41" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<add public="1" get="inline" set="null" line="45" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" get="inline" set="null" line="49" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" get="inline" set="null" line="53" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" get="inline" set="null" line="57" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" get="inline" set="null" line="61" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" get="inline" set="null" line="65" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" get="inline" set="null" line="69" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" get="inline" set="null" line="73" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" get="inline" set="null" line="77" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" get="inline" set="null" line="81" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" get="inline" set="null" line="85" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" get="inline" set="null" line="89" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<isNeg public="1" get="inline" set="null" line="93" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isNeg>
		<isZero public="1" get="inline" set="null" line="97" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<e path="Bool"/>
</f></isZero>
		<complement public="1" get="inline" set="null" line="101" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" get="inline" set="null" line="105" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
		<ucompare public="1" set="method" line="109" static="1">
			<f a="a:b">
				<c path="haxe.Int32"/>
				<c path="haxe.Int32"/>
				<c path="Int"/>
			</f>
			<haxe_doc>Compare two Int32 in unsigned mode.</haxe_doc>
		</ucompare>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="haxe.Log" params="" file="/usr/share/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" set="dynamic" line="54" static="1"><f a=""><e path="Void"/></f></clear>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/share/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams>
		<c path="Array"><d/></c>
		<meta><m n=":optional"/></meta>
	</customParams>
	<className><c path="String"/></className>
</a></typedef>
	<enum path="haxe.StackItem" params="" file="/usr/share/haxe/std/haxe/Stack.hx" module="haxe.Stack">
		<Module a="m"><c path="String"/></Module>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><c path="Int"/></Lambda>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<c path="Int"/>
		</FilePos>
		<CFunction/>
		<haxe_doc>Elements return by [Stack] methods.</haxe_doc>
	</enum>
	<class path="haxe.Stack" params="" file="/usr/share/haxe/std/haxe/Stack.hx">
		<callStack public="1" set="method" line="46" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="97" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.</haxe_doc>
		</exceptionStack>
		<toString public="1" set="method" line="131" static="1">
			<f a="stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<itemToString set="method" line="140" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<e path="Void"/>
</f></itemToString>
		<makeStack set="method" line="167" static="1"><f a="s">
	<c path="Array"><c path="String"/></c>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></makeStack>
		<haxe_doc>Get informations about the call stack.</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/share/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" set="method" line="259" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" line="291" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" line="340" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<getData public="1" get="inline" set="null" line="255"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<toHex public="1" set="method" line="241"><f a=""><c path="String"/></f></toHex>
		<toString public="1" set="method" line="218"><f a=""><c path="String"/></f></toString>
		<readString public="1" set="method" line="168"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<compare public="1" set="method" line="130"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<sub public="1" set="method" line="103"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<blit public="1" set="method" line="71"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<set public="1" get="inline" set="null" line="53"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<get public="1" get="inline" set="null" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<b><t path="haxe.io.BytesData"/></b>
		<length public="1" set="null"><c path="Int"/></length>
		<new set="method" line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/share/haxe/std/haxe/io/BytesBuffer.hx">
		<getBytes public="1" set="method" line="126">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.</haxe_doc>
		</getBytes>
		<addBytes public="1" get="inline" set="null" line="100"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<add public="1" get="inline" set="null" line="81"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addByte public="1" get="inline" set="null" line="63"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<b><e path="Void"/></b>
		<new public="1" set="method" line="45"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/share/haxe/std/haxe/io/BytesData.hx"><c path="neko.NativeString"/></typedef>
	<class path="haxe.io.Output" params="" file="/usr/share/haxe/std/haxe/io/Output.hx">
		<LN2 line="34" static="1"><c path="Float"/></LN2>
		<_float_bytes line="358" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_float_bytes>
		<_double_bytes line="359" static="1"><f a=":">
	<c path="Float"/>
	<e path="Bool"/>
	<t path="haxe.io.BytesData"/>
</f></_double_bytes>
		<writeString public="1" set="method" line="348"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></writeString>
		<writeInput public="1" set="method" line="326"><f a="i:?bufsize">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeInput>
		<prepare public="1" set="method" line="323">
			<f a="nbytes">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Inform that we are about to write at least a specified number of bytes.
		The underlying implementation can allocate proper working space depending
		on this information, or simply ignore it. This is not a mandatory call
		but a tip and is only used in some specific cases.</haxe_doc>
		</prepare>
		<writeInt32 public="1" set="method" line="303"><f a="x">
	<c path="haxe.Int32"/>
	<e path="Void"/>
</f></writeInt32>
		<writeUInt30 public="1" set="method" line="288"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt30>
		<writeInt31 public="1" set="method" line="271"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt31>
		<writeUInt24 public="1" set="method" line="258"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt24>
		<writeInt24 public="1" set="method" line="253"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt24>
		<writeUInt16 public="1" set="method" line="242"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeUInt16>
		<writeInt16 public="1" set="method" line="237"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt16>
		<writeInt8 public="1" set="method" line="231"><f a="x">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt8>
		<writeDouble public="1" set="method" line="154"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1" set="method" line="100"><f a="x">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeFullBytes public="1" set="method" line="92"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></writeFullBytes>
		<write public="1" set="method" line="81"><f a="s">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></write>
		<setEndian set="method" line="74"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<close public="1" set="method" line="71"><f a=""><e path="Void"/></f></close>
		<flush public="1" set="method" line="68"><f a=""><e path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="45"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="41"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the [writeChar] and maybe the [write], [flush] and [close]
	methods. See [File.write] and [String.write] for two ways of creating an
	Output.</haxe_doc>
	</class>
	<class path="haxe.io.BytesOutput" params="" file="/usr/share/haxe/std/haxe/io/BytesOutput.hx">
		<extends path="haxe.io.Output"/>
		<getBytes public="1" set="method" line="126"><f a=""><c path="haxe.io.Bytes"/></f></getBytes>
		<writeBytes public="1" set="method" line="52" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="44" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<b><c path="haxe.io.BytesBuffer"/></b>
		<new public="1" set="method" line="35"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/share/haxe/std/haxe/io/Eof.hx">
		<toString set="method" line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>This exception is raised when reading while data is no longer available in the [Input].</haxe_doc>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/share/haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
	</enum>
	<class path="haxe.io.Input" params="" file="/usr/share/haxe/std/haxe/io/Input.hx">
		<_float_of_bytes line="419" static="1"><f a=":">
	<unknown/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_float_of_bytes>
		<_double_of_bytes line="420" static="1"><f a=":">
	<unknown/>
	<e path="Bool"/>
	<c path="Float"/>
</f></_double_of_bytes>
		<readString public="1" set="method" line="408"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<readInt32 public="1" set="method" line="393"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readUInt30 public="1" set="method" line="384"><f a=""><c path="Int"/></f></readUInt30>
		<readInt31 public="1" set="method" line="367"><f a=""><c path="Int"/></f></readInt31>
		<readUInt24 public="1" set="method" line="360"><f a=""><c path="Int"/></f></readUInt24>
		<readInt24 public="1" set="method" line="350"><f a=""><c path="Int"/></f></readInt24>
		<readUInt16 public="1" set="method" line="344"><f a=""><c path="Int"/></f></readUInt16>
		<readInt16 public="1" set="method" line="335"><f a=""><c path="Int"/></f></readInt16>
		<readInt8 public="1" set="method" line="328"><f a=""><c path="Int"/></f></readInt8>
		<readDouble public="1" set="method" line="255"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1" set="method" line="201"><f a=""><c path="Float"/></f></readFloat>
		<readLine public="1" set="method" line="184"><f a=""><c path="String"/></f></readLine>
		<readUntil public="1" set="method" line="176"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<read public="1" set="method" line="164"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readFullBytes public="1" set="method" line="156"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<readAll public="1" set="method" line="80"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<setEndian set="method" line="73"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<close public="1" set="method" line="70"><f a=""><e path="Void"/></f></close>
		<readBytes public="1" set="method" line="49"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="40"><f a=""><c path="Int"/></f></readByte>
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<haxe_doc>An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.</haxe_doc>
	</class>
	<class path="haxe.rtti.Meta" params="" file="/usr/share/haxe/std/haxe/rtti/Meta.hx">
		<getType public="1" set="method" line="35" static="1">
			<f a="t">
				<d/>
				<d><c path="Array"><d/></c></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given type (class or enum)</haxe_doc>
		</getType>
		<getStatics public="1" set="method" line="47" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given class fields or enum constructors</haxe_doc>
		</getStatics>
		<getFields public="1" set="method" line="59" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given class static fields</haxe_doc>
		</getFields>
		<haxe_doc>An api to access classes and enums metadata at runtime.</haxe_doc>
	</class>
	<class path="massive.haxe.Exception" params="" file="/usr/lib/haxe/lib/mlib/0,4,0/massive/haxe/Exception.hx">
		<toString public="1" set="method" line="78">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Returns a string representation of this exception.
	 * 
	 * Format: <type>: <message> at <className>#<methodName> (<lineNumber>)]]></haxe_doc>
		</toString>
		<info public="1" set="null">
			<t path="haxe.PosInfos"/>
			<haxe_doc>* The pos infos from where the exception was created.</haxe_doc>
		</info>
		<message public="1" set="null">
			<c path="String"/>
			<haxe_doc>* A description of the exception</haxe_doc>
		</message>
		<type public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The exception type. 
	 * 
	 * Should be the fully qualified name of the Exception class. e.g. 'massive.io.IOException'</haxe_doc>
		</type>
		<new public="1" set="method" line="66">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param	message			a description of the exception</haxe_doc>
		</new>
		<haxe_doc>* Instances of the class Exception and its subclasses, when thrown, provide information about
 * the type and location of erroneous behavior.
 * 
 * An application should lookout for and handle raised exceptions through try/catch blocks located
 * in an appropriate place.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.haxe.util.ReflectUtil" params="" file="/usr/lib/haxe/lib/mlib/0,4,0/massive/haxe/util/ReflectUtil.hx">
		<here public="1" set="method" line="43" static="1">
			<f a="?info">
				<t path="haxe.PosInfos"/>
				<t path="haxe.PosInfos"/>
			</f>
			<haxe_doc>* Return information about the location this method is called.</haxe_doc>
		</here>
		<haxe_doc>* Utility class to help with reflection.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.Assert" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/Assert.hx">
		<assertionCount public="1" line="43" static="1">
			<c path="Int"/>
			<haxe_doc>* The incremented number of assertions made during the execution of a set of tests.</haxe_doc>
		</assertionCount>
		<isTrue public="1" set="method" line="51" static="1">
			<f a="value:?info">
				<e path="Bool"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is true.
	 *  
	 * @param	value				value expected to be true
	 * @throws	AssertionException	if value is not true</haxe_doc>
		</isTrue>
		<isFalse public="1" set="method" line="63" static="1">
			<f a="value:?info">
				<e path="Bool"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is false.
	 *  
	 * @param	value				value expected to be false
	 * @throws	AssertionException	if value is not false</haxe_doc>
		</isFalse>
		<isNull public="1" set="method" line="75" static="1">
			<f a="value:?info">
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is null.
	 *  
	 * @param	value				value expected to be null
	 * @throws	AssertionException	if value is not null</haxe_doc>
		</isNull>
		<isNotNull public="1" set="method" line="87" static="1">
			<f a="value:?info">
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is not null.
	 *  
	 * @param	value				value expected not to be null
	 * @throws	AssertionException	if value is null</haxe_doc>
		</isNotNull>
		<isNaN public="1" set="method" line="99" static="1">
			<f a="value:?info">
				<c path="Float"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is Math.NaN.
	 *  
	 * @param	value				value expected to be Math.NaN
	 * @throws	AssertionException	if value is not Math.NaN</haxe_doc>
		</isNaN>
		<isNotNaN public="1" set="method" line="111" static="1">
			<f a="value:?info">
				<c path="Float"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is not Math.NaN.
	 *  
	 * @param	value				value expected not to be Math.NaN
	 * @throws	AssertionException	if value is Math.NaN</haxe_doc>
		</isNotNaN>
		<isType public="1" set="method" line="123" static="1">
			<f a="value:type">
				<d/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is of a specific type.
	 * 
	 * @param	value				value expected to be of a given type
	 * @param	type				type the value should be</haxe_doc>
		</isType>
		<isNotType public="1" set="method" line="135" static="1">
			<f a="value:type">
				<d/>
				<c path="Class"><d/></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is not of a specific type.
	 * 
	 * @param	value				value expected to not be of a given type
	 * @param	type				type the value should not be</haxe_doc>
		</isNotType>
		<areEqual public="1" set="method" line="148" static="1">
			<f a="expected:actual:?info">
				<d/>
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that two values are equal.
	 *  
	 * @param	expected			expected value
	 * @param	actual				actual value
	 * @throws	AssertionException	if expected is not equal to the actual value</haxe_doc>
		</areEqual>
		<areNotEqual public="1" set="method" line="161" static="1">
			<f a="expected:actual:?info">
				<d/>
				<d/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Assert that two values are not equal.
	 *  
	 * @param	expected			expected value
	 * @param	actual				actual value
	 * @throws	AssertionException	if expected is equal to the actual value</haxe_doc>
		</areNotEqual>
		<fail public="1" set="method" line="173" static="1">
			<f a="msg:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Force an assertion failure.
	 *  
	 * @param	msg				message describing the assertion which failed
	 * @throws	AssertionException	thrown automatically</haxe_doc>
		</fail>
		<haxe_doc>* Used to make assertions about values in test cases.
 *  
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.MUnitException" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/MUnitException.hx">
		<extends path="massive.haxe.Exception"/>
		<new public="1" set="method" line="47">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
	 * 
	 * @param	message			a description of the exception
	 * @param	info			pos infos from where the exception was thrown</haxe_doc>
		</new>
		<haxe_doc>* Base exception type for all exceptions raised by munit.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.AssertionException" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/AssertionException.hx">
		<extends path="massive.munit.MUnitException"/>
		<new public="1" set="method" line="46">
			<f a="msg:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param	msg				message describing the assertion which failed
	 * @param	info			pos infos of where the failing assertion was made</haxe_doc>
		</new>
		<haxe_doc>* Exception thrown when an assertion is made which is not correct.
 *  
 * @author Mike Stead
 * @see Assert</haxe_doc>
	</class>
	<class path="massive.munit.ITestResultClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/ITestResultClient.hx" interface="1">
		<reportFinalStatistics public="1" set="method">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<d/>
			</f>
			<haxe_doc>* Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data if any</haxe_doc>
		</reportFinalStatistics>
		<addIgnore public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test has been ignored.
	 *
	 * @param	result			an ignored test</haxe_doc>
		</addIgnore>
		<addError public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result</haxe_doc>
		</addError>
		<addFail public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test fails.
	 *  
	 * @param	result			a failed test result</haxe_doc>
		</addFail>
		<addPass public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test passes.
	 *  
	 * @param	result			a passed test result</haxe_doc>
		</addPass>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier for the client.</haxe_doc>
		</id>
		<completionHandler public="1" get="get_completeHandler" set="set_completeHandler">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Handler which if present, should be called when the client has completed its processing of the results.</haxe_doc>
		</completionHandler>
		<haxe_doc><![CDATA[* Interface which all test result clients should adhere to.
 * <p>
 * A test result client is responsible for interpreting the results of tests as
 * they are executed by a test runner.
 * </p>
 * 
 * @author Mike Stead
 * @see TestRunner]]></haxe_doc>
	</class>
	<class path="massive.munit.IAdvancedTestResultClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/ITestResultClient.hx" module="massive.munit.ITestResultClient" interface="1">
		<implements path="massive.munit.ITestResultClient"/>
		<setCurrentTestClass public="1" set="method">
			<f a="className">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called before a new test class in run.
	 *
	 * @param	result			a stub test result</haxe_doc>
		</setCurrentTestClass>
		<haxe_doc><![CDATA[* Updated Interface which all test result clients should adhere to.
 * <p>
 * A test result client is responsible for interpreting the results of tests as
 * they are executed by a test runner.
 * </p>
 * 
 * @author Dominic De Lorenzo
 * @see TestRunner]]></haxe_doc>
	</class>
	<class path="massive.munit.ICoverageTestResultClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/ITestResultClient.hx" module="massive.munit.ITestResultClient" interface="1">
		<implements path="massive.munit.IAdvancedTestResultClient"/>
		<reportFinalCoverage public="1" set="method">
			<f a="?percent:missingCoverageResults:summary:?classBreakdown:?packageBreakdown:?executionFrequency">
				<c path="Float"/>
				<c path="Array"><t path="massive.munit.CoverageResult"/></c>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called after all test classes have finished
	 *
	 * @param	percent					overall coverage percentage
	 * @param	coverageResults			missing coverage results
	 * @param	summary					high level coverage report
	 * @param	classBreakdown			results per class
 	 * @param	packageBreakdown		results per package
	 * @param	executionFrequency		statement/branch frequency</haxe_doc>
		</reportFinalCoverage>
		<setCurrentTestClassCoverage public="1" set="method">
			<f a="result">
				<t path="massive.munit.CoverageResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called after all tests have completed for current class
	 *
	 * @param	result			missing class coverage covered by tests</haxe_doc>
		</setCurrentTestClassCoverage>
		<haxe_doc>* Interface for supporting test coverage
 * 
 * @author Dominic De Lorenzo
 * @see TestRunner</haxe_doc>
	</class>
	<typedef path="massive.munit.CoverageResult" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/ITestResultClient.hx" module="massive.munit.ITestResultClient"><a>
	<percent><c path="Float"/></percent>
	<className><c path="String"/></className>
	<blocks><c path="Array"><c path="String"/></c></blocks>
</a></typedef>
	<class path="massive.munit.TestClassHelper" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/TestClassHelper.hx">
		<META_TAG_BEFORE_CLASS public="1" get="inline" set="null" line="51" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking method to be called before all tests in a class.</haxe_doc>
		</META_TAG_BEFORE_CLASS>
		<META_TAG_AFTER_CLASS public="1" get="inline" set="null" line="56" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking method to be called after all tests in a class.</haxe_doc>
		</META_TAG_AFTER_CLASS>
		<META_TAG_BEFORE public="1" get="inline" set="null" line="61" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking method to be called before each test in a class.</haxe_doc>
		</META_TAG_BEFORE>
		<META_TAG_AFTER public="1" get="inline" set="null" line="66" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking method to be called after each test in a class.</haxe_doc>
		</META_TAG_AFTER>
		<META_TAG_TEST public="1" get="inline" set="null" line="71" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking test method in class.</haxe_doc>
		</META_TAG_TEST>
		<META_TAG_ASYNC_TEST public="1" get="inline" set="null" line="76" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking asynchronous test method in class.</haxe_doc>
		</META_TAG_ASYNC_TEST>
		<META_TAG_IGNORE public="1" get="inline" set="null" line="81" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking a test method to ignore.</haxe_doc>
		</META_TAG_IGNORE>
		<META_PARAM_ASYNC_TEST public="1" get="inline" set="null" line="88" static="1">
			<c path="String"/>
			<haxe_doc>* Param for META_TAG_TEST, marking test method in class as asynchronous.
     *
     * @deprecated As of 0.9.1.4, use @AsyncTest instead.</haxe_doc>
		</META_PARAM_ASYNC_TEST>
		<META_TAG_TEST_DEBUG public="1" get="inline" set="null" line="93" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking test method in class for execution in debug mode only.</haxe_doc>
		</META_TAG_TEST_DEBUG>
		<META_TAGS public="1" line="98" static="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* Array of all valid meta tags.</haxe_doc>
		</META_TAGS>
		<nullFunc set="method" line="344"><f a=""><e path="Void"/></f></nullFunc>
		<sortTestsByName set="method" line="337"><f a="x:y">
	<t path="massive.munit.TestCaseData"/>
	<t path="massive.munit.TestCaseData"/>
	<c path="Int"/>
</f></sortTestsByName>
		<addTest set="method" line="320"><f a="field:testFunction:testInstance:isAsync:isIgnored:description">
	<c path="String"/>
	<d/>
	<d/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></addTest>
		<searchForMatchingTags set="method" line="275"><f a="fieldName:func:funcMeta">
	<c path="String"/>
	<d/>
	<d/>
	<e path="Void"/>
</f></searchForMatchingTags>
		<scanForTests set="method" line="261"><f a="fieldMeta">
	<d/>
	<e path="Void"/>
</f></scanForTests>
		<collateFieldMeta set="method" line="210"><f a="inherintanceChain">
	<c path="Array"><c path="Class"><d/></c></c>
	<d/>
</f></collateFieldMeta>
		<getInheritanceChain set="method" line="202"><f a="clazz">
	<c path="Class"><d/></c>
	<c path="Array"><c path="Class"><d/></c></c>
</f></getInheritanceChain>
		<parse set="method" line="192"><f a="type">
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></parse>
		<current public="1" set="method" line="187">
			<f a=""><d/></f>
			<haxe_doc>* Get the current test in the iterable list of tests.
	 * 
	 * @return	current test in the iterable list of tests</haxe_doc>
		</current>
		<next public="1" set="method" line="177">
			<f a=""><d/></f>
			<haxe_doc>* Returns the next test in the iterable list of tests.
	 * 
	 * @return	if another test is available it's returned, otherwise returns null</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="167">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>* Check if there is another test in the iterable list of tests.
	 * 
	 * @return	true if there is one or more tests available, false if not.</haxe_doc>
		</hasNext>
		<isDebug><e path="Bool"/></isDebug>
		<className public="1" set="null"><c path="String"/></className>
		<index><c path="Int"/></index>
		<tests><c path="Array"><t path="massive.munit.TestCaseData"/></c></tests>
		<after public="1" set="null">
			<d/>
			<haxe_doc>* The life cycle method to be called once, after each test in the class is executed.</haxe_doc>
		</after>
		<before public="1" set="null">
			<d/>
			<haxe_doc>* The life cycle method to be called once, before each test in the class is executed.</haxe_doc>
		</before>
		<afterClass public="1" set="null">
			<d/>
			<haxe_doc>* The life cycle method to be called once, after tests in the class are executed.</haxe_doc>
		</afterClass>
		<beforeClass public="1" set="null">
			<d/>
			<haxe_doc>* The life cycle method to be called once, before tests in the class are executed.</haxe_doc>
		</beforeClass>
		<test public="1" set="null">
			<d/>
			<haxe_doc>* The instance of the test class this helper is wrapping.</haxe_doc>
		</test>
		<type public="1" set="null">
			<c path="Class"><d/></c>
			<haxe_doc>* The type of the test class this helper is wrapping.</haxe_doc>
		</type>
		<new public="1" set="method" line="146">
			<f a="type:?isDebug">
				<c path="Class"><d/></c>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
	 * 
	 * @param	type			type of test class this helper is wrapping</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A helper used to discover, and provide access to, the test and life cycle methods of a test class.
 * <p>
 * This object implements Iterable methods (http://haxe.org/ref/iterators) for iterating over the test 
 * cases it discovers in a class.
 * </p>
 * <p>
 * <code>for (test in testHelper){ ... }</code>
 * </p>
 * 
 * @author Mike Stead]]></haxe_doc>
	</class>
	<typedef path="massive.munit.TestCaseData" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/TestClassHelper.hx" module="massive.munit.TestClassHelper"><a>
	<test><d/></test>
	<scope><d/></scope>
	<result><c path="massive.munit.TestResult"/></result>
</a></typedef>
	<class path="massive.munit.TestResult" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/TestResult.hx">
		<get_type set="method" line="110"><f a=""><e path="massive.munit.TestResultType"/></f></get_type>
		<type public="1" get="get_type" set="null"><e path="massive.munit.TestResultType"/></type>
		<error public="1">
			<d/>
			<haxe_doc>* If this test was erroneous, the error that was captured.</haxe_doc>
		</error>
		<failure public="1">
			<c path="massive.munit.AssertionException"/>
			<haxe_doc>* If this test failed, the assertion exception that was captured.</haxe_doc>
		</failure>
		<ignore public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the test is ignored or not.</haxe_doc>
		</ignore>
		<async public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the test is asynchronous or not.</haxe_doc>
		</async>
		<get_location set="method" line="68"><f a=""><c path="String"/></f></get_location>
		<location public="1" get="get_location" set="null">
			<c path="String"/>
			<haxe_doc>* The fully qualified location of this test. (i.e. package.ClassName#method)</haxe_doc>
		</location>
		<description public="1">
			<c path="String"/>
			<haxe_doc>* An optional description.</haxe_doc>
		</description>
		<className public="1">
			<c path="String"/>
			<haxe_doc>* The name of the class (qualified with package) where the test is located.</haxe_doc>
		</className>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the test. This maps to the name of the test method.</haxe_doc>
		</name>
		<executionTime public="1">
			<c path="Float"/>
			<haxe_doc>* The execution time of the test in milliseconds.</haxe_doc>
		</executionTime>
		<passed public="1">
			<e path="Bool"/>
			<haxe_doc>* Whether the test passed or not.</haxe_doc>
		</passed>
		<new public="1" set="method" line="97">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Class constructor.</haxe_doc>
		</new>
		<haxe_doc>* The value object which contains the result of a test.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<enum path="massive.munit.TestResultType" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/TestResult.hx" module="massive.munit.TestResult">
		<UNKNOWN/>
		<PASS/>
		<IGNORE/>
		<FAIL/>
		<ERROR/>
	</enum>
	<class path="massive.munit.async.IAsyncDelegateObserver" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/async/IAsyncDelegateObserver.hx" interface="1">
		<asyncDelegateCreatedHandler public="1" set="method">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when AsyncDelegate is generated through the AsyncFactory.
	 * Enables an observer to cancel any pending async handlers.
	 *
	 * @param	delegate		delegate which received the successful callback</haxe_doc>
		</asyncDelegateCreatedHandler>
		<asyncTimeoutHandler public="1" set="method">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when an AsyncDelegate being observed does not receive its asynchronous callback
	 * in the time allowed.
	 * 
	 * @param	delegate		delegate whose asynchronous callback timed out</haxe_doc>
		</asyncTimeoutHandler>
		<asyncResponseHandler public="1" set="method">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when an AsyncDelegate being observed receives a successful asynchronous callback.
	 * 
	 * @param	delegate		delegate which received the successful callback</haxe_doc>
		</asyncResponseHandler>
		<haxe_doc>* Interface which observers of an AsyncDelegate should implement.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.TestRunner" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/TestRunner.hx">
		<implements path="massive.munit.async.IAsyncDelegateObserver"/>
		<createAsyncFactory set="method" line="417"><f a=""><c path="massive.munit.async.AsyncFactory"/></f></createAsyncFactory>
		<asyncDelegateCreatedHandler public="1" set="method" line="412"><f a="delegate">
	<c path="massive.munit.async.AsyncDelegate"/>
	<e path="Void"/>
</f></asyncDelegateCreatedHandler>
		<asyncTimeoutHandler public="1" set="method" line="397">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when an AsyncDelegate being observed does not receive its asynchronous callback
     * in the time allowed.
     *
     * @param	delegate		delegate whose asynchronous callback timed out</haxe_doc>
		</asyncTimeoutHandler>
		<asyncResponseHandler public="1" set="method" line="378">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when an AsyncDelegate being observed receives a successful asynchronous callback.
     *
     * @param	delegate		delegate which received the successful callback</haxe_doc>
		</asyncResponseHandler>
		<clientCompletionHandler set="method" line="358"><f a="resultClient">
	<c path="massive.munit.ITestResultClient"/>
	<e path="Void"/>
</f></clientCompletionHandler>
		<executeTestCase set="method" line="297"><f a="testCaseData:async">
	<d/>
	<e path="Bool"/>
	<e path="Void"/>
</f></executeTestCase>
		<executeTestCases set="method" line="265"><f a=""><e path="Void"/></f></executeTestCases>
		<execute set="method" line="225"><f a=""><e path="Void"/></f></execute>
		<run public="1" set="method" line="181">
			<f a="testSuiteClasses">
				<c path="Array"><c path="Class"><c path="massive.munit.TestSuite"/></c></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Run one or more suites of unit tests.
     *
     * @param	testSuiteClasses</haxe_doc>
		</run>
		<debug public="1" set="method" line="170">
			<f a="testSuiteClasses">
				<c path="Array"><c path="Class"><c path="massive.munit.TestSuite"/></c></c>
				<e path="Void"/>
			</f>
			<haxe_doc>* Run one or more suites of unit tests containing @TestDebug.
     *
     * @param	testSuiteClasses</haxe_doc>
		</debug>
		<addResultClient public="1" set="method" line="156">
			<f a="resultClient">
				<c path="massive.munit.ITestResultClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Add one or more result clients to interpret test results.
     *
     * @param	resultClient			a result client to interpret test results</haxe_doc>
		</addResultClient>
		<isDebug set="null"><e path="Bool"/></isDebug>
		<testStartTime><c path="Float"/></testStartTime>
		<startTime><c path="Float"/></startTime>
		<emptyParams><c path="Array"><d/></c></emptyParams>
		<set_asyncFactory set="method" line="116"><f a="value">
	<c path="massive.munit.async.AsyncFactory"/>
	<c path="massive.munit.async.AsyncFactory"/>
</f></set_asyncFactory>
		<asyncFactory public="1" set="set_asyncFactory"><c path="massive.munit.async.AsyncFactory"/></asyncFactory>
		<suiteIndex><c path="Int"/></suiteIndex>
		<asyncDelegate><c path="massive.munit.async.AsyncDelegate"/></asyncDelegate>
		<asyncPending><e path="Bool"/></asyncPending>
		<testSuites><c path="Array"><c path="massive.munit.TestSuite"/></c></testSuites>
		<activeHelper><c path="massive.munit.TestClassHelper"/></activeHelper>
		<clients><c path="Array"><c path="massive.munit.ITestResultClient"/></c></clients>
		<clientCompleteCount><c path="Int"/></clientCompleteCount>
		<ignoreCount><c path="Int"/></ignoreCount>
		<passCount><c path="Int"/></passCount>
		<errorCount><c path="Int"/></errorCount>
		<failCount><c path="Int"/></failCount>
		<testCount><c path="Int"/></testCount>
		<running public="1" set="null"><e path="Bool"/></running>
		<get_clientCount set="method" line="95"><f a=""><c path="Int"/></f></get_clientCount>
		<clientCount public="1" get="get_clientCount" set="null"><c path="Int"/></clientCount>
		<completionHandler public="1">
			<f a="">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Handler called when all tests have been executed and all clients
     * have completed processing the results.</haxe_doc>
		</completionHandler>
		<new public="1" set="method" line="137">
			<f a="resultClient">
				<c path="massive.munit.ITestResultClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
     *
     * @param	resultClient	a result client to interpret test results</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Runner used to execute one or more suites of unit tests.
 *
 * <pre>
 * // Create a test runner with client (PrintClient) and pass it a collection of test suites
 * public class TestMain
 * {
 *     public function new()
 *     {
 *         var suites = new Array<Class<massive.munit.TestSuite>>();
 *         suites.push(TestSuite);
 *
 *         var runner:TestRunner = new TestRunner(new PrintClient());
 *         runner.run(suites);
 *     }
 * }
 *
 * // A test suite with one test class (MathUtilTest)
 * class TestSuite extends massive.unit.TestSuite
 * {
 *     public function new()
 *     {
 *          add(MathUtilTest);
 *     }
 * }
 *
 * // A test class with one test case (testAdd)
 * class MathUtilTest
 * {
 *     @Test
 *     public function testAdd():Void
 *     {
 *         Assert.areEqual(2, MathUtil.add(1,1));
 *     }
 * }
 * </pre>
 * @author Mike Stead
 * @see TestSuite]]></haxe_doc>
	</class>
	<class path="massive.munit.UnhandledException" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/UnhandledException.hx">
		<extends path="massive.munit.MUnitException"/>
		<getStackTrace set="method" line="63"><f a="source">
	<d/>
	<c path="String"/>
</f></getStackTrace>
		<formatLocation set="method" line="51"><f a="source:testLocation">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></formatLocation>
		<new public="1" set="method" line="45">
			<f a="source:testLocation">
				<d/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* @param source	exception which went unhandled
     * @param location 	test location which triggered exception</haxe_doc>
		</new>
		<haxe_doc>* Exception thrown when a test triggers an exception in code which was not captured.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.async.AsyncDelegate" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/async/AsyncDelegate.hx">
		<DEFAULT_TIMEOUT public="1" get="inline" set="null" line="46" static="1">
			<c path="Int"/>
			<haxe_doc>* Default timeout period in milliseconds.</haxe_doc>
		</DEFAULT_TIMEOUT>
		<actualTimeoutHandler set="method" line="157"><f a=""><e path="Void"/></f></actualTimeoutHandler>
		<timeoutHandler set="method" line="147"><f a=""><e path="Void"/></f></timeoutHandler>
		<delayActualResponseHandler set="method" line="141"><f a=""><e path="Void"/></f></delayActualResponseHandler>
		<responseHandler set="method" line="126"><f a="?params">
	<c path="Array"><d/></c>
	<e path="Void"/>
</f></responseHandler>
		<cancelTest public="1" set="method" line="119">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Cancels pending async timeout.</haxe_doc>
		</cancelTest>
		<runTest public="1" set="method" line="111">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Execute the remainder of the asynchronous test. This should be called after observer
	 * has been notified of a successful asynchronous response.</haxe_doc>
		</runTest>
		<params><c path="Array"><d/></c></params>
		<deferredTimer><c path="massive.munit.util.Timer"/></deferredTimer>
		<canceled public="1" set="null"><e path="Bool"/></canceled>
		<timer><c path="massive.munit.util.Timer"/></timer>
		<handler><d/></handler>
		<testCase><d/></testCase>
		<timedOut public="1" set="null"><e path="Bool"/></timedOut>
		<timeoutDelay public="1" set="null"><c path="Int"/></timeoutDelay>
		<delegateHandler public="1" set="null">
			<d/>
			<haxe_doc><![CDATA[* The handler for a successful response from the asynchronous call.
	 * <p>
	 * This notifies the observer of the success. The observer can then call runTest when
	 * it is ready for the remainder of the async test to be run.
	 * </p>]]></haxe_doc>
		</delegateHandler>
		<info public="1">
			<t path="haxe.PosInfos"/>
			<haxe_doc>* Pos infos of the test which requests an instance of this delegate.</haxe_doc>
		</info>
		<observer public="1">
			<c path="massive.munit.async.IAsyncDelegateObserver"/>
			<haxe_doc>* Observer interested in the outcome of this asynchronous call.</haxe_doc>
		</observer>
		<new public="1" set="method" line="91">
			<f a="testCase:handler:?timeout:?info">
				<d/>
				<d/>
				<c path="Int"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
	 * 
	 * @param	testCase			test case instance where the async test originated
	 * @param	handler				the handler in the test case for a successful async response
	 * @param	?timeout			[optional] number of milliseconds to wait before timing out. Defaults to 400
	 * @param	?info				[optional] pos infos of the test which requests an instance of this delegate</haxe_doc>
		</new>
		<haxe_doc>* Sits between an asynchronous test and an observer (typically the TestRunner), notifying 
 * the observer when an asynchronous test has returned or timed out.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.async.AsyncFactory" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/async/AsyncFactory.hx">
		<createHandler public="1" set="method" line="92">
			<f a="testCase:handler:?timeout:?info">
				<d/>
				<d/>
				<c path="Int"/>
				<t path="haxe.PosInfos"/>
				<d/>
			</f>
			<haxe_doc>* Create an AsyncDelegate which handles variable number of parameters to be passed to its handler.
	 * 
	 * @param	testCase			test case instance where the async test originated
	 * @param	handler				the handler in the test case for a successful async response
	 * @param	?timeout			[optional] number of milliseconds to wait before timing out
	 * @param	?info				[optional] pos infos of the test which requests an instance of this delegate
	 * @return	a delegate function for handling the asynchronous response from an async test case</haxe_doc>
		</createHandler>
		<asyncDelegateCount public="1" set="null">
			<c path="Int"/>
			<haxe_doc>* The number of AsyncDelegates created by this factory.</haxe_doc>
		</asyncDelegateCount>
		<observer public="1">
			<c path="massive.munit.async.IAsyncDelegateObserver"/>
			<haxe_doc>* Observer for all AsyncDelegates this factory creates.</haxe_doc>
		</observer>
		<new public="1" set="method" line="77">
			<f a="observer">
				<c path="massive.munit.async.IAsyncDelegateObserver"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
	 * 
	 * @param	observer			an observer for all AsyncDelegate this factory creates</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Factory for asynchronous delegates.
 * 
 * <p>
 * An instance of this factory is passed to test methods which define themselves as asynchronous.
 * They can then request a delegate handler to 
 * </p>
 * <pre>
 * class TimerTest
 * {
 *     @Test("Async")
 *     public function testTimer(factory:AsyncFactory):Void
 *     {
 *         var handler:Dynamic = factory.createHandler(this, onTestTimer);
 *         Timer.delay(onTestTimer, 100);
 *     }
 *     
 *     private function onTestTimer():Void
 *     {
 *         Assert.isTrue(true);
 *     }
 * }
 * </pre>
 * 
 * @author Mike Stead]]></haxe_doc>
	</class>
	<class path="massive.munit.async.AsyncTimeoutException" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/async/AsyncTimeoutException.hx">
		<extends path="massive.munit.MUnitException"/>
		<new public="1" set="method" line="44">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* {@inheritDoc}</haxe_doc>
		</new>
		<haxe_doc>* Exception thrown when a test makes an assertion which is incorrect.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.async.MissingAsyncDelegateException" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/async/MissingAsyncDelegateException.hx">
		<extends path="massive.munit.MUnitException"/>
		<new public="1" set="method" line="44">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* {@inheritDoc}</haxe_doc>
		</new>
		<haxe_doc>* Exception thrown when an asynchronous test does not create an AsyncDelegate.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.client.AbstractTestResultClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/AbstractTestResultClient.hx">
		<implements path="massive.munit.ICoverageTestResultClient"/>
		<implements path="massive.munit.IAdvancedTestResultClient"/>
		<sortTestResults set="method" line="289"><f a="a:b">
	<c path="massive.munit.TestResult"/>
	<c path="massive.munit.TestResult"/>
	<c path="Int"/>
</f></sortTestResults>
		<customTrace set="method" line="283"><f a="value:?info">
	<unknown/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></customTrace>
		<printOverallResult set="method" line="276"><f a="result">
	<e path="Bool"/>
	<e path="Void"/>
</f></printOverallResult>
		<printFinalStatistics set="method" line="271">
			<f a="result:testCount:passCount:failCount:errorCount:ignoreCount:time">
				<e path="Bool"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Override to print final summary</haxe_doc>
		</printFinalStatistics>
		<printReports set="method" line="263">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Override to print any additional reports (e.g. overall coverage)</haxe_doc>
		</printReports>
		<finalizeTestClass set="method" line="252">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when a test class has completed executing all tests</haxe_doc>
		</finalizeTestClass>
		<updateTestClass set="method" line="243">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called after every test has executed</haxe_doc>
		</updateTestClass>
		<initializeTestClass set="method" line="230">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Called when a new test class is about to execute tests</haxe_doc>
		</initializeTestClass>
		<reportFinalStatistics public="1" set="method" line="209">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<d/>
			</f>
			<haxe_doc>* Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data</haxe_doc>
		</reportFinalStatistics>
		<reportFinalCoverage public="1" set="method" line="188"><f a="?percent:missingCoverageResults:summary:?classBreakdown:?packageBreakdown:?executionFrequency">
	<c path="Float"/>
	<c path="Array"><t path="massive.munit.CoverageResult"/></c>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></reportFinalCoverage>
		<setCurrentTestClassCoverage public="1" set="method" line="181"><f a="result">
	<t path="massive.munit.CoverageResult"/>
	<e path="Void"/>
</f></setCurrentTestClassCoverage>
		<addIgnore public="1" set="method" line="175">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test has been ignored.
	 *
	 * @param	result			an ignored test</haxe_doc>
		</addIgnore>
		<addError public="1" set="method" line="164">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result</haxe_doc>
		</addError>
		<addFail public="1" set="method" line="153">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test fails.
	 *  
	 * @param	result			a failed test result</haxe_doc>
		</addFail>
		<addPass public="1" set="method" line="142">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test passes.
	 *  
	 * @param	result			a passed test result</haxe_doc>
		</addPass>
		<setCurrentTestClass public="1" set="method" line="124">
			<f a="className">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Classed when test class changes
	*
	* @param className		qualified name of current test class</haxe_doc>
		</setCurrentTestClass>
		<init set="method" line="95"><f a=""><e path="Void"/></f></init>
		<finalResult><e path="Bool"/></finalResult>
		<originalTrace><d/></originalTrace>
		<totalCoverageResults><c path="Array"><t path="massive.munit.CoverageResult"/></c></totalCoverageResults>
		<totalCoverageReport><c path="String"/></totalCoverageReport>
		<totalCoveragePercent><c path="Float"/></totalCoveragePercent>
		<totalResults><c path="Array"><c path="massive.munit.TestResult"/></c></totalResults>
		<traces><c path="Array"><c path="String"/></c></traces>
		<currentCoverageResult><t path="massive.munit.CoverageResult"/></currentCoverageResult>
		<currentClassResults><c path="Array"><c path="massive.munit.TestResult"/></c></currentClassResults>
		<currentTestClass><c path="String"/></currentTestClass>
		<ignoreCount><c path="Int"/></ignoreCount>
		<errorCount><c path="Int"/></errorCount>
		<failCount><c path="Int"/></failCount>
		<passCount><c path="Int"/></passCount>
		<get_output set="method" line="62"><f a=""><c path="String"/></f></get_output>
		<output public="1" get="get_output" set="null"><c path="String"/></output>
		<set_completeHandler set="method" line="53"><f a="value">
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<e path="Void"/>
	</f>
</f></set_completeHandler>
		<get_completeHandler set="method" line="49"><f a=""><f a="">
	<c path="massive.munit.ITestResultClient"/>
	<e path="Void"/>
</f></f></get_completeHandler>
		<completionHandler public="1" get="get_completeHandler" set="set_completeHandler">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Handler which if present, is called when the client has completed generating its results.</haxe_doc>
		</completionHandler>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier for the client.</haxe_doc>
		</id>
		<new public="1" set="method" line="90"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2012 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.munit.client.HTTPClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/HTTPClient.hx">
		<implements path="massive.munit.IAdvancedTestResultClient"/>
		<DEFAULT_SERVER_URL public="1" get="inline" set="null" line="43" static="1"><c path="String"/></DEFAULT_SERVER_URL>
		<DEFAULT_ID public="1" get="inline" set="null" line="47" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<CLIENT_HEADER_KEY public="1" get="inline" set="null" line="52" static="1">
			<c path="String"/>
			<haxe_doc>* HTTP header key. Contains id of client the HTTPClient is decorating.</haxe_doc>
		</CLIENT_HEADER_KEY>
		<PLATFORM_HEADER_KEY public="1" get="inline" set="null" line="57" static="1">
			<c path="String"/>
			<haxe_doc>* HTTP header key. Contains id of platform being tests (flash9,flash,js,neko,cpp,php).</haxe_doc>
		</PLATFORM_HEADER_KEY>
		<queue line="60" static="1"><c path="Array"><c path="massive.munit.client.URLRequest"/></c></queue>
		<responsePending line="61" static="1"><e path="Bool"/></responsePending>
		<dispatchNextRequest set="method" line="227" static="1"><f a=""><e path="Void"/></f></dispatchNextRequest>
		<onError set="method" line="216"><f a="msg">
	<c path="String"/>
	<e path="Void"/>
</f></onError>
		<onData set="method" line="205"><f a="data">
	<c path="String"/>
	<e path="Void"/>
</f></onData>
		<platform set="method" line="193"><f a=""><c path="String"/></f></platform>
		<sendResult set="method" line="173"><f a="result">
	<unknown/>
	<e path="Void"/>
</f></sendResult>
		<reportFinalStatistics public="1" set="method" line="166">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<d/>
			</f>
			<haxe_doc>* Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data if any</haxe_doc>
		</reportFinalStatistics>
		<addIgnore public="1" set="method" line="150">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test has been ignored.
	 *
	 * @param	result			an ignored test</haxe_doc>
		</addIgnore>
		<addError public="1" set="method" line="140">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result</haxe_doc>
		</addError>
		<addFail public="1" set="method" line="130">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test fails.
	 *  
	 * @param	result			a failed test result</haxe_doc>
		</addFail>
		<addPass public="1" set="method" line="120">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test passes.
	 *  
	 * @param	result			a passed test result</haxe_doc>
		</addPass>
		<setCurrentTestClass public="1" set="method" line="107">
			<f a="className">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Classed when test class changes
	*
	* @param className		qualified name of current test class</haxe_doc>
		</setCurrentTestClass>
		<queueRequest><e path="Bool"/></queueRequest>
		<request><c path="massive.munit.client.URLRequest"/></request>
		<url><c path="String"/></url>
		<client><c path="massive.munit.ITestResultClient"/></client>
		<set_completeHandler set="method" line="77"><f a="value">
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<e path="Void"/>
	</f>
</f></set_completeHandler>
		<get_completeHandler set="method" line="73"><f a=""><f a="">
	<c path="massive.munit.ITestResultClient"/>
	<e path="Void"/>
</f></f></get_completeHandler>
		<completionHandler public="1" get="get_completeHandler" set="set_completeHandler">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Handler which if present, is called when the client has completed sending the test results to the specificied url. 
	 * This will be called once an HTTP response has been recieved.</haxe_doc>
		</completionHandler>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier for the client.</haxe_doc>
		</id>
		<new public="1" set="method" line="94">
			<f a="client:?url:?queueRequest">
				<c path="massive.munit.ITestResultClient"/>
				<c path="String"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* 
	 * @param	client				the test result client to decorate
	 * @param	url					the url to send test results to
	 * @param	?queueRequest		[optional] whether to add http requests to a global queue. Default is true.
	 * @param	?httpRequest		[optional] a custom http request to use to dispatch the result.</haxe_doc>
		</new>
		<haxe_doc>* Decorates other ITestResultClient's, adding behavior to post test results to a specified url.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.client.URLRequest" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/HTTPClient.hx" module="massive.munit.client.HTTPClient">
		<send public="1" set="method" line="288"><f a=""><e path="Void"/></f></send>
		<setHeader public="1" set="method" line="277"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></setHeader>
		<createClient set="method" line="266"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></createClient>
		<client public="1"><c path="haxe.Http"/></client>
		<headers><c path="Hash"><c path="String"/></c></headers>
		<url><c path="String"/></url>
		<data public="1"><d/></data>
		<onError public="1"><f a="">
	<d/>
	<e path="Void"/>
</f></onError>
		<onData public="1"><f a="">
	<d/>
	<e path="Void"/>
</f></onData>
		<new public="1" set="method" line="259"><f a="url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="massive.munit.client.JUnitReportClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/JUnitReportClient.hx">
		<implements path="massive.munit.IAdvancedTestResultClient"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="46" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<startTestSuite set="method" line="208"><f a=""><e path="Void"/></f></startTestSuite>
		<endTestSuite set="method" line="190"><f a=""><e path="Void"/></f></endTestSuite>
		<reportFinalStatistics public="1" set="method" line="182">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Float"/>
				<d/>
			</f>
			<haxe_doc>* Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data</haxe_doc>
		</reportFinalStatistics>
		<addIgnore public="1" set="method" line="162">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test has been ignored.
	 *
	 * @param	result			an ignored test</haxe_doc>
		</addIgnore>
		<addError public="1" set="method" line="146">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result</haxe_doc>
		</addError>
		<addFail public="1" set="method" line="130">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test fails.
	 *  
	 * @param	result			a failed test result</haxe_doc>
		</addFail>
		<addPass public="1" set="method" line="118">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Called when a test passes.
	 *  
	 * @param	result			a passed test result</haxe_doc>
		</addPass>
		<setCurrentTestClass public="1" set="method" line="102">
			<f a="className">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Classed when test class changes
	*
	* @param className		qualified name of current test class</haxe_doc>
		</setCurrentTestClass>
		<suiteExecutionTime><c path="Float"/></suiteExecutionTime>
		<suiteErrorCount><c path="Int"/></suiteErrorCount>
		<suiteFailCount><c path="Int"/></suiteFailCount>
		<suitePassCount><c path="Int"/></suitePassCount>
		<currentTestClass><c path="String"/></currentTestClass>
		<testSuiteXML><c path="StringBuf"/></testSuiteXML>
		<xml><c path="StringBuf"/></xml>
		<newline public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Newline delimiter. Defaults to '\n'.
	 * 
	 * <p>
	 * Should be set before the client is passed to a test runner.
	 * </p>]]></haxe_doc>
		</newline>
		<set_completeHandler set="method" line="61"><f a="value">
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<e path="Void"/>
	</f>
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<e path="Void"/>
	</f>
</f></set_completeHandler>
		<get_completeHandler set="method" line="57"><f a=""><f a="">
	<c path="massive.munit.ITestResultClient"/>
	<e path="Void"/>
</f></f></get_completeHandler>
		<completionHandler public="1" get="get_completeHandler" set="set_completeHandler">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<e path="Void"/>
			</f>
			<haxe_doc>* Handler which if present, is called when the client has completed generating its results.</haxe_doc>
		</completionHandler>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier for the client.</haxe_doc>
		</id>
		<new public="1" set="method" line="86">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* Class constructor.</haxe_doc>
		</new>
		<haxe_doc>* Generates xml formatted tests results compliant for processing by the JUnitReport 
 * Apache Ant task (http://ant.apache.org/manual/Tasks/junitreport.html).
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.client.PrintClientBase" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/PrintClientBase.hx">
		<extends path="massive.munit.client.AbstractTestResultClient"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="43" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<indentString set="method" line="262"><f a="value:?indent">
	<c path="String"/>
	<c path="Int"/>
	<c path="String"/>
</f></indentString>
		<printLine public="1" set="method" line="255"><f a="value:?indent">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></printLine>
		<print public="1" set="method" line="250"><f a="value">
	<d/>
	<e path="Void"/>
</f></print>
		<printOverallResult set="method" line="244" override="1"><f a="result">
	<e path="Bool"/>
	<e path="Void"/>
</f></printOverallResult>
		<printFinalStatistics set="method" line="229" override="1"><f a="result:testCount:passCount:failCount:errorCount:ignoreCount:time">
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></printFinalStatistics>
		<filterIngored set="method" line="224"><f a="result">
	<c path="massive.munit.TestResult"/>
	<e path="Bool"/>
</f></filterIngored>
		<printFinalIgnoredStatistics set="method" line="203"><f a="count">
	<c path="Int"/>
	<e path="Void"/>
</f></printFinalIgnoredStatistics>
		<printReports set="method" line="198" override="1"><f a=""><e path="Void"/></f></printReports>
		<printIndentedLines set="method" line="188"><f a="value:?indent">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></printIndentedLines>
		<reportFinalCoverage public="1" set="method" line="137" override="1"><f a="?percent:missingCoverageResults:summary:?classBreakdown:?packageBreakdown:?executionFrequency">
	<c path="Float"/>
	<c path="Array"><t path="massive.munit.CoverageResult"/></c>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></reportFinalCoverage>
		<setCurrentTestClassCoverage public="1" set="method" line="121" override="1"><f a="result">
	<t path="massive.munit.CoverageResult"/>
	<e path="Void"/>
</f></setCurrentTestClassCoverage>
		<finalizeTestClass set="method" line="94" override="1"><f a=""><e path="Void"/></f></finalizeTestClass>
		<updateTestClass set="method" line="77" override="1"><f a="result">
	<c path="massive.munit.TestResult"/>
	<e path="Void"/>
</f></updateTestClass>
		<initializeTestClass set="method" line="71" override="1"><f a=""><e path="Void"/></f></initializeTestClass>
		<init set="method" line="62" override="1"><f a=""><e path="Void"/></f></init>
		<divider2><c path="String"/></divider2>
		<divider><c path="String"/></divider>
		<includeIgnoredReport><e path="Bool"/></includeIgnoredReport>
		<verbose public="1"><e path="Bool"/></verbose>
		<new public="1" set="method" line="51"><f a="?includeIgnoredReport">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>**
* Copyright 2012 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.munit.client.PrintClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/PrintClient.hx">
		<extends path="massive.munit.client.PrintClientBase"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="64" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<printLine public="1" set="method" line="183" override="1"><f a="value:?indent">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></printLine>
		<print public="1" set="method" line="159" override="1"><f a="value">
	<d/>
	<e path="Void"/>
</f></print>
		<reportFinalStatistics public="1" set="method" line="154" override="1"><f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<d/>
</f></reportFinalStatistics>
		<printOverallResult set="method" line="142" override="1"><f a="result">
	<e path="Bool"/>
	<e path="Void"/>
</f></printOverallResult>
		<init set="method" line="83" override="1"><f a=""><e path="Void"/></f></init>
		<new public="1" set="method" line="77"><f a="?includeIgnoredReport">
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Generates basic text formatted test result output.
 * 
 * <p>
 * Example output:
 * </p>
 * <pre>
 * MUnit Results
 * ------------------------------
 * 
 * Class: SampleTest ...
 * Class: sub.ItemTest ..
 * 
 * PASSED
 * Tests: 5  Passed: 5  Failed: 0 Errors: 0 Ignored: 0 Time: 0.202
 * ==============================
 * </pre>
 * 
 * @author Mike Stead]]></haxe_doc>
	</class>
	<class path="massive.munit.client.ExternalPrintClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/PrintClientBase.hx" module="massive.munit.client.PrintClientBase" interface="1">
		<printSummary public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></printSummary>
		<addCoverageSummary public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addCoverageSummary>
		<addCoverageReportSection public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></addCoverageReportSection>
		<addMissingCoverageClass public="1" set="method"><f a="className:?percent">
	<c path="String"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addMissingCoverageClass>
		<createCoverageReport public="1" set="method"><f a="?percent">
	<c path="Float"/>
	<e path="Void"/>
</f></createCoverageReport>
		<addTestClassCoverageItem public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestClassCoverageItem>
		<addTestClassCoverage public="1" set="method"><f a="className:?percent">
	<c path="String"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addTestClassCoverage>
		<addTestIgnore public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestIgnore>
		<addTestError public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestError>
		<addTestFail public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestFail>
		<addTestPass public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestPass>
		<trace public="1" set="method"><f a="value">
	<d/>
	<e path="Void"/>
</f></trace>
		<setTestClassResult public="1" set="method"><f a="resultType">
	<c path="Int"/>
	<e path="Void"/>
</f></setTestClassResult>
		<printToTestClassSummary public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></printToTestClassSummary>
		<createTestClass public="1" set="method"><f a="className">
	<c path="String"/>
	<e path="Void"/>
</f></createTestClass>
		<setResultBackground public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setResultBackground>
		<printLine public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></printLine>
		<print public="1" set="method"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></print>
		<setResult public="1" set="method"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setResult>
		<queue public="1" set="method"><f a="methodName:?args">
	<c path="String"/>
	<d/>
	<e path="Bool"/>
</f></queue>
	</class>
	<class path="massive.munit.client.ExternalPrintClientJS" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/PrintClientBase.hx" module="massive.munit.client.PrintClientBase">
		<implements path="massive.munit.client.ExternalPrintClient"/>
		<serialiseToHTML public="1" set="method" line="540"><f a="value">
	<d/>
	<c path="String"/>
</f></serialiseToHTML>
		<convertToJavaScript public="1" set="method" line="512"><f a="method:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></convertToJavaScript>
		<queue public="1" set="method" line="482"><f a="method:?args">
	<c path="String"/>
	<d/>
	<e path="Bool"/>
</f></queue>
		<printSummary public="1" set="method" line="475"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></printSummary>
		<addCoverageSummary public="1" set="method" line="467"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addCoverageSummary>
		<addCoverageReportSection public="1" set="method" line="462"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></addCoverageReportSection>
		<addMissingCoverageClass public="1" set="method" line="457"><f a="className:?percent">
	<c path="String"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addMissingCoverageClass>
		<createCoverageReport public="1" set="method" line="452"><f a="?percent">
	<c path="Float"/>
	<e path="Void"/>
</f></createCoverageReport>
		<addTestClassCoverageItem public="1" set="method" line="445"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestClassCoverageItem>
		<addTestClassCoverage public="1" set="method" line="440"><f a="className:?percent">
	<c path="String"/>
	<c path="Float"/>
	<e path="Void"/>
</f></addTestClassCoverage>
		<addTestIgnore public="1" set="method" line="435"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestIgnore>
		<addTestError public="1" set="method" line="430"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestError>
		<addTestFail public="1" set="method" line="425"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestFail>
		<addTestPass public="1" set="method" line="419"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></addTestPass>
		<setTestClassResult public="1" set="method" line="414"><f a="resultType">
	<c path="Int"/>
	<e path="Void"/>
</f></setTestClassResult>
		<printToTestClassSummary public="1" set="method" line="409"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></printToTestClassSummary>
		<createTestClass public="1" set="method" line="404"><f a="className">
	<c path="String"/>
	<e path="Void"/>
</f></createTestClass>
		<trace public="1" set="method" line="399"><f a="value">
	<d/>
	<e path="Void"/>
</f></trace>
		<setResultBackground public="1" set="method" line="392"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setResultBackground>
		<setResult public="1" set="method" line="387"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></setResult>
		<printLine public="1" set="method" line="382"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></printLine>
		<print public="1" set="method" line="377"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></print>
		<new public="1" set="method" line="313"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="massive.munit.client.RichPrintClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/RichPrintClient.hx">
		<extends path="massive.munit.client.PrintClientBase"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="44" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<printLine public="1" set="method" line="295" override="1"><f a="value:?indent">
	<d/>
	<c path="Int"/>
	<e path="Void"/>
</f></printLine>
		<print public="1" set="method" line="279" override="1"><f a="value">
	<d/>
	<e path="Void"/>
</f></print>
		<customTrace set="method" line="270" override="1"><f a="value:?info">
	<unknown/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></customTrace>
		<printOverallResult set="method" line="264" override="1"><f a="result">
	<e path="Bool"/>
	<e path="Void"/>
</f></printOverallResult>
		<printFinalStatistics set="method" line="249" override="1"><f a="result:testCount:passCount:failCount:errorCount:ignoreCount:time">
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></printFinalStatistics>
		<printReports set="method" line="244" override="1"><f a=""><e path="Void"/></f></printReports>
		<printMissingCoverage set="method" line="230"><f a="missingCoverageResults">
	<c path="Array"><t path="massive.munit.CoverageResult"/></c>
	<e path="Void"/>
</f></printMissingCoverage>
		<trim set="method" line="214"><f a="output">
	<c path="String"/>
	<c path="String"/>
</f></trim>
		<reportFinalCoverage public="1" set="method" line="182" override="1"><f a="?percent:missingCoverageResults:summary:?classBreakdown:?packageBreakdown:?executionFrequency">
	<c path="Float"/>
	<c path="Array"><t path="massive.munit.CoverageResult"/></c>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></reportFinalCoverage>
		<setCurrentTestClassCoverage public="1" set="method" line="166" override="1"><f a="result">
	<t path="massive.munit.CoverageResult"/>
	<e path="Void"/>
</f></setCurrentTestClassCoverage>
		<getTestClassResultType set="method" line="157"><f a=""><e path="massive.munit.TestResultType"/></f></getTestClassResultType>
		<finalizeTestClass set="method" line="136" override="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>* summarises result for currently executing test class
	* and update visual state of test class</haxe_doc>
		</finalizeTestClass>
		<serializeTestResult set="method" line="100"><f a="result">
	<c path="massive.munit.TestResult"/>
	<c path="String"/>
</f></serializeTestResult>
		<updateTestClass set="method" line="69" override="1"><f a="result">
	<c path="massive.munit.TestResult"/>
	<e path="Void"/>
</f></updateTestClass>
		<initializeTestClass set="method" line="62" override="1"><f a=""><e path="Void"/></f></initializeTestClass>
		<init set="method" line="55" override="1"><f a=""><e path="Void"/></f></init>
		<external><c path="massive.munit.client.ExternalPrintClient"/></external>
		<testClassResultType><e path="massive.munit.TestResultType"/></testClassResultType>
		<new public="1" set="method" line="49"><f a=""><e path="Void"/></f></new>
		<haxe_doc>**
* Copyright 2012 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="massive.munit.client.SummaryReportClient" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/client/SummaryReportClient.hx">
		<extends path="massive.munit.client.AbstractTestResultClient"/>
		<DEFAULT_ID public="1" line="59" static="1"><c path="String"/></DEFAULT_ID>
		<printReports set="method" line="106" override="1"><f a=""><e path="Void"/></f></printReports>
		<printOverallResult set="method" line="100" override="1"><f a="result">
	<e path="Bool"/>
	<e path="Void"/>
</f></printOverallResult>
		<printFinalStatistics set="method" line="67" override="1"><f a="result:testCount:passCount:failCount:errorCount:ignoreCount:time">
	<e path="Bool"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Float"/>
	<e path="Void"/>
</f></printFinalStatistics>
		<new public="1" set="method" line="61"><f a=""><e path="Void"/></f></new>
		<haxe_doc>Provides a high level summary report in text format

e.g.

result:true
count:49
count:7
pass:5
fail:2
error:0
ignore:2
time:1234.3

# className#method
# className#method
# className#method
# className#method
# className#method
# className#method
# className#method
# className#method
# className#method
# ... plus 5 more</haxe_doc>
	</class>
	<class path="massive.munit.util.MathUtil" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/util/MathUtil.hx">
		<round public="1" set="method" line="48" static="1">
			<f a="value:precision">
				<c path="Float"/>
				<c path="Int"/>
				<c path="Float"/>
			</f>
			<haxe_doc>* Round a floating point number to a given decimal place.
	 * 
	 * @param	value			number to round up
	 * @param	precision		precision to round the value to
	 * @return	the rounded value</haxe_doc>
		</round>
		<new public="1" set="method" line="38"><f a=""><e path="Void"/></f></new>
		<haxe_doc>* Utility class for math related operations.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.util.Timer" params="" file="/usr/lib/haxe/lib/munit/0,9,4,2/massive/munit/util/Timer.hx">
		<delay public="1" set="method" line="138" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<c path="massive.munit.util.Timer"/>
</f></delay>
		<stamp public="1" set="method" line="153" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>*	Returns a timestamp, in seconds</haxe_doc>
		</stamp>
		<runLoop set="method" line="117"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></runLoop>
		<run public="1" set="dynamic" line="113"><f a=""><e path="Void"/></f></run>
		<stop public="1" set="method" line="87"><f a=""><e path="Void"/></f></stop>
		<runThread><c path="neko.vm.Thread"/></runThread>
		<id><t path="Null"><c path="Int"/></t></id>
		<new public="1" set="method" line="69"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>**
* Copyright 2012 Massive Interactive. All rights reserved.
* 
* Redistribution and use in source and binary forms, with or without modification, are
* permitted provided that the following conditions are met:
* 
*    1. Redistributions of source code must retain the above copyright notice, this list of
*       conditions and the following disclaimer.
* 
*    2. Redistributions in binary form must reproduce the above copyright notice, this list
*       of conditions and the following disclaimer in the documentation and/or other materials
*       provided with the distribution.
* 
* THIS SOFTWARE IS PROVIDED BY MASSIVE INTERACTIVE ``AS IS'' AND ANY EXPRESS OR IMPLIED
* WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
* FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL MASSIVE INTERACTIVE OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
* ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* The views and conclusions contained in the software and documentation are those of the
* authors and should not be interpreted as representing official policies, either expressed
* or implied, of Massive Interactive.
**</haxe_doc>
	</class>
	<class path="neko.NativeArray" params="T" file="/usr/share/haxe/std/neko/NativeArray.hx">
		<alloc public="1" params="T" get="inline" set="null" line="29" static="1"><f a="length">
	<c path="Int"/>
	<c path="neko.NativeArray"><c path="alloc.T"/></c>
</f></alloc>
		<blit public="1" params="T" get="inline" set="null" line="33" static="1"><f a="dst:dstPos:src:srcPos:length">
	<c path="neko.NativeArray"><c path="blit.T"/></c>
	<c path="Int"/>
	<c path="neko.NativeArray"><c path="blit.T"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<ofArrayCopy public="1" params="T" get="inline" set="null" line="37" static="1"><f a="a">
	<c path="Array"><c path="ofArrayCopy.T"/></c>
	<c path="neko.NativeArray"><c path="ofArrayCopy.T"/></c>
</f></ofArrayCopy>
		<ofArrayRef public="1" params="T" get="inline" set="null" line="41" static="1"><f a="a">
	<c path="Array"><c path="ofArrayRef.T"/></c>
	<c path="neko.NativeArray"><c path="ofArrayRef.T"/></c>
</f></ofArrayRef>
		<sub public="1" params="T" get="inline" set="null" line="45" static="1"><f a="a:pos:len">
	<c path="neko.NativeArray"><c path="sub.T"/></c>
	<c path="Int"/>
	<c path="Int"/>
	<c path="neko.NativeArray"><c path="sub.T"/></c>
</f></sub>
		<toArray public="1" params="T" get="inline" set="null" line="49" static="1"><f a="a">
	<c path="neko.NativeArray"><c path="toArray.T"/></c>
	<c path="Array"><c path="toArray.T"/></c>
</f></toArray>
		<length public="1" get="inline" set="null" line="53" static="1"><f a="a">
	<c path="neko.NativeArray"><d/></c>
	<c path="Int"/>
</f></length>
	</class>
	<class path="neko.NativeString" params="" file="/usr/share/haxe/std/neko/NativeString.hx">
		<ofString public="1" get="inline" set="null" line="29" static="1"><f a="s">
	<c path="String"/>
	<c path="neko.NativeString"/>
</f></ofString>
		<toString public="1" get="inline" set="null" line="33" static="1"><f a="s">
	<c path="neko.NativeString"/>
	<c path="String"/>
</f></toString>
		<length public="1" get="inline" set="null" line="37" static="1"><f a="s">
	<c path="neko.NativeString"/>
	<c path="Int"/>
</f></length>
	</class>
	<typedef path="neko.Sys" params="" file="/usr/share/haxe/std/neko/Sys.hx"><c path="Sys"/></typedef>
	<enum path="neko.vm.ThreadHandle" params="" file="/usr/share/haxe/std/neko/vm/Thread.hx" module="neko.vm.Thread"/>
	<class path="neko.vm.Thread" params="" file="/usr/share/haxe/std/neko/vm/Thread.hx">
		<current public="1" set="method" line="49" static="1">
			<f a=""><c path="neko.vm.Thread"/></f>
			<haxe_doc>Returns the current thread.</haxe_doc>
		</current>
		<create public="1" set="method" line="56" static="1">
			<f a="callb">
				<f a=""><e path="Void"/></f>
				<c path="neko.vm.Thread"/>
			</f>
			<haxe_doc>Creates a new thread that will execute the [callb] function, then exit.</haxe_doc>
		</create>
		<readMessage public="1" set="method" line="65" static="1">
			<f a="block">
				<e path="Bool"/>
				<d/>
			</f>
			<haxe_doc>Reads a message from the thread queue. If [block] is true, the function
		blocks until a message is available. If [block] is false, the function
		returns [null] if no message is available.</haxe_doc>
		</readMessage>
		<thread_create line="132" static="1">
			<f a=":">
				<f a="_">
					<unknown/>
					<e path="Void"/>
				</f>
				<unknown/>
				<e path="neko.vm.ThreadHandle"/>
			</f>
			<haxe_doc><![CDATA[Starts an OS message loop after [osInitialize] has been done.
		In that state, the UI handled by this thread will be updated and
		[sync] calls can be performed. The loop returns when [exitLoop] is
		called for this thread.
	**
	public static function osLoop() {
		if( os_loop == null ) throw "Please call osInitialize() first";
		os_loop();
	}

	/**
		The function [f] will be called by this thread if it's in [osLoop].
		[sync] returns immediatly. See [osInitialize] remarks.
	**
	public function sync( f : Void -> Void ) {
		os_sync(handle,f);
	}

	/**
		The function [f] will be called by this thread and the calling thread
		will wait until the result is available then return its value.
	**
	public function syncResult<T>( f : Void -> T ) : T {
		if( this == current() )
			return f();
		var v = new neko.vm.Lock();
		var r = null;
		sync(function() {
			r = f();
			v.release();
		});
		v.wait();
		return r;
	}

	/**
		Exit from [osLoop].
	**
	public function exitLoop() {
		os_loop_stop(handle);
	}

	/**
		If you want to use the [osLoop], [sync] and [syncResult] methods, you
		need to call [osInitialize] before creating any thread or calling [current].
		This will load [os.ndll] library and initialize UI methods for each thread.
	**
	public static function osInitialize() {
		os_loop = neko.Lib.load("os","os_loop",0);
		os_loop_stop = neko.Lib.load("os","os_loop_stop",1);
		os_sync = neko.Lib.load("os","os_sync",2);
	}

	static var os_loop = null;
	static var os_loop_stop = null;
	static var os_sync = null;]]></haxe_doc>
		</thread_create>
		<thread_current line="133" static="1"><f a=""><e path="neko.vm.ThreadHandle"/></f></thread_current>
		<thread_send line="134" static="1"><f a=":">
	<e path="neko.vm.ThreadHandle"/>
	<d/>
	<unknown/>
</f></thread_send>
		<thread_read_message line="135" static="1"><f a="">
	<e path="Bool"/>
	<unknown/>
</f></thread_read_message>
		<__compare set="method" line="69"><f a="t">
	<a><handle set="null"><unknown/></handle></a>
	<unknown/>
</f></__compare>
		<sendMessage public="1" set="method" line="41">
			<f a="msg">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>Send a message to the thread queue. This message can be readed by using [readMessage].</haxe_doc>
		</sendMessage>
		<handle><e path="neko.vm.ThreadHandle"/></handle>
		<new set="method" line="34"><f a="h">
	<e path="neko.vm.ThreadHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.hamcrest.Exception" params="" file="/usr/lib/haxe/lib/hamcrest/1,0,0/org/hamcrest/Exception.hx">
		<toString public="1" set="method" line="23"><f a=""><c path="String"/></f></toString>
		<info public="1" set="null"><t path="haxe.PosInfos"/></info>
		<cause public="1" set="null"><d/></cause>
		<message public="1" set="null"><c path="String"/></message>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1" set="method" line="15"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>**
* Copyright 2011 hamcrest.org. See LICENSE.txt
**</haxe_doc>
	</class>
	<class path="org.hamcrest.AssertionException" params="" file="/usr/lib/haxe/lib/hamcrest/1,0,0/org/hamcrest/AssertionException.hx">
		<extends path="org.hamcrest.Exception"/>
		<new public="1" set="method" line="10"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>**
* Copyright 2011 hamcrest.org. See LICENSE.txt
**</haxe_doc>
	</class>
	<class path="org.hamcrest.IllegalArgumentException" params="" file="/usr/lib/haxe/lib/hamcrest/1,0,0/org/hamcrest/Exception.hx" module="org.hamcrest.Exception">
		<extends path="org.hamcrest.Exception"/>
		<new public="1" set="method" line="36"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.hamcrest.MissingImplementationException" params="" file="/usr/lib/haxe/lib/hamcrest/1,0,0/org/hamcrest/Exception.hx" module="org.hamcrest.Exception">
		<extends path="org.hamcrest.Exception"/>
		<new public="1" set="method" line="44"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="org.hamcrest.UnsupportedOperationException" params="" file="/usr/lib/haxe/lib/hamcrest/1,0,0/org/hamcrest/Exception.hx" module="org.hamcrest.Exception">
		<extends path="org.hamcrest.Exception"/>
		<new public="1" set="method" line="52"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="sys.io.FileHandle" params="" file="/usr/share/haxe/std/neko/_std/sys/io/File.hx" module="sys.io.File"/>
	<class path="sys.io.File" params="" file="/usr/share/haxe/std/neko/_std/sys/io/File.hx">
		<getContent public="1" set="method" line="35" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getContent>
		<getBytes public="1" set="method" line="39" static="1"><f a="path">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></getBytes>
		<saveContent public="1" set="method" line="43" static="1"><f a="path:content">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></saveContent>
		<saveBytes public="1" set="method" line="49" static="1"><f a="path:bytes">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></saveBytes>
		<read public="1" set="method" line="55" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileInput"/>
</f></read>
		<write public="1" set="method" line="59" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileOutput"/>
</f></write>
		<append public="1" set="method" line="63" static="1"><f a="path:?binary">
	<c path="String"/>
	<e path="Bool"/>
	<c path="sys.io.FileOutput"/>
</f></append>
		<copy public="1" set="method" line="67" static="1"><f a="src:dst">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></copy>
		<file_contents line="75" static="1"><f a="">
	<unknown/>
	<c path="String"/>
</f></file_contents>
		<file_open line="76" static="1"><f a=":">
	<unknown/>
	<unknown/>
	<e path="sys.io.FileHandle"/>
</f></file_open>
		<haxe_doc>API for reading and writing to files.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="sys.io.FileInput" params="" file="/usr/share/haxe/std/neko/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<file_eof line="75" static="1"><f a="">
	<e path="sys.io.FileHandle"/>
	<e path="Bool"/>
</f></file_eof>
		<file_read line="77" static="1"><f a=":::">
	<e path="sys.io.FileHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_read>
		<file_read_char line="78" static="1"><f a="">
	<e path="sys.io.FileHandle"/>
	<c path="Int"/>
</f></file_read_char>
		<file_close line="80" static="1"><f a="">
	<e path="sys.io.FileHandle"/>
	<unknown/>
</f></file_close>
		<file_seek line="81" static="1"><f a="::">
	<e path="sys.io.FileHandle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="82" static="1"><f a="">
	<e path="sys.io.FileHandle"/>
	<c path="Int"/>
</f></file_tell>
		<eof public="1" set="method" line="71"><f a=""><e path="Bool"/></f></eof>
		<tell public="1" set="method" line="66"><f a=""><c path="Int"/></f></tell>
		<seek public="1" set="method" line="62"><f a="p:pos">
	<c path="Int"/>
	<e path="sys.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<close public="1" set="method" line="57" override="1"><f a=""><e path="Void"/></f></close>
		<readBytes public="1" set="method" line="46" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="35" override="1"><f a=""><c path="Int"/></f></readByte>
		<__f><e path="sys.io.FileHandle"/></__f>
		<new set="method" line="31"><f a="f">
	<e path="sys.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.read] to create a [FileInput]</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="/usr/share/haxe/std/neko/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<file_close line="60" static="1"><f a="">
	<e path="sys.io.FileHandle"/>
	<unknown/>
</f></file_close>
		<file_seek line="61" static="1"><f a="::">
	<e path="sys.io.FileHandle"/>
	<c path="Int"/>
	<c path="Int"/>
	<unknown/>
</f></file_seek>
		<file_tell line="62" static="1"><f a="">
	<e path="sys.io.FileHandle"/>
	<c path="Int"/>
</f></file_tell>
		<file_flush line="64" static="1"><f a="">
	<e path="sys.io.FileHandle"/>
	<unknown/>
</f></file_flush>
		<file_write line="65" static="1"><f a=":::">
	<e path="sys.io.FileHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></file_write>
		<file_write_char line="66" static="1"><f a=":">
	<e path="sys.io.FileHandle"/>
	<c path="Int"/>
	<unknown/>
</f></file_write_char>
		<tell public="1" set="method" line="56"><f a=""><c path="Int"/></f></tell>
		<seek public="1" set="method" line="52"><f a="p:pos">
	<c path="Int"/>
	<e path="sys.io.FileSeek"/>
	<e path="Void"/>
</f></seek>
		<close public="1" set="method" line="47" override="1"><f a=""><e path="Void"/></f></close>
		<flush public="1" set="method" line="43" override="1"><f a=""><e path="Void"/></f></flush>
		<writeBytes public="1" set="method" line="39" override="1"><f a="s:p:l">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="35" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<__f><e path="sys.io.FileHandle"/></__f>
		<new set="method" line="31"><f a="f">
	<e path="sys.io.FileHandle"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>Use [sys.io.File.write] to create a [FileOutput]</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="sys.io.FileSeek" params="" file="/usr/share/haxe/std/sys/io/FileSeek.hx">
		<SeekEnd/>
		<SeekCur/>
		<SeekBegin/>
	</enum>
	<class path="sys.net.Host" params="" file="/usr/share/haxe/std/neko/_std/sys/net/Host.hx">
		<localhost public="1" set="method" line="45" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the local computer host name</haxe_doc>
		</localhost>
		<host_resolve line="53" static="1"><f a="">
	<unknown/>
	<c path="haxe.Int32"/>
</f></host_resolve>
		<host_reverse line="54" static="1"><f a="">
	<c path="haxe.Int32"/>
	<c path="String"/>
</f></host_reverse>
		<host_to_string line="55" static="1"><f a="">
	<c path="haxe.Int32"/>
	<c path="String"/>
</f></host_to_string>
		<host_local line="56" static="1"><f a=""><c path="String"/></f></host_local>
		<reverse public="1" set="method" line="41">
			<f a=""><c path="String"/></f>
			<haxe_doc>Perform a reverse-DNS query to resolve a host name from an IP.</haxe_doc>
		</reverse>
		<toString public="1" set="method" line="37">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the IP representation of the host</haxe_doc>
		</toString>
		<ip public="1" set="null">
			<c path="haxe.Int32"/>
			<haxe_doc>The actual IP corresponding to the host.</haxe_doc>
		</ip>
		<new public="1" set="method" line="33">
			<f a="name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Creates a new Host : the name can be an IP in the form "127.0.0.1" or an host name such as "google.com", in which case
		the corresponding IP address is resolved using DNS. An exception occur if the host name could not be found.</haxe_doc>
		</new>
		<haxe_doc>A given IP host name.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
	<enum path="sys.net._Socket.SocketHandle" params="" file="/usr/share/haxe/std/neko/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket"/>
	<class path="sys.net._Socket.SocketOutput" params="" file="/usr/share/haxe/std/neko/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket">
		<extends path="haxe.io.Output"/>
		<socket_close line="67" static="1"><f a="">
	<e path="sys.net._Socket.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<socket_send_char line="68" static="1"><f a=":">
	<e path="sys.net._Socket.SocketHandle"/>
	<c path="Int"/>
	<unknown/>
</f></socket_send_char>
		<socket_send line="69" static="1"><f a=":::">
	<e path="sys.net._Socket.SocketHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></socket_send>
		<close public="1" set="method" line="62" override="1"><f a=""><e path="Void"/></f></close>
		<writeBytes public="1" set="method" line="51" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></writeBytes>
		<writeByte public="1" set="method" line="40" override="1"><f a="c">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<__s><e path="sys.net._Socket.SocketHandle"/></__s>
		<new public="1" set="method" line="36"><f a="s">
	<e path="sys.net._Socket.SocketHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="sys.net._Socket.SocketInput" params="" file="/usr/share/haxe/std/neko/_std/sys/net/Socket.hx" private="1" module="sys.net.Socket">
		<extends path="haxe.io.Input"/>
		<socket_recv line="114" static="1"><f a=":::">
	<e path="sys.net._Socket.SocketHandle"/>
	<t path="haxe.io.BytesData"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></socket_recv>
		<socket_recv_char line="115" static="1"><f a="">
	<e path="sys.net._Socket.SocketHandle"/>
	<c path="Int"/>
</f></socket_recv_char>
		<socket_close line="116" static="1"><f a="">
	<e path="sys.net._Socket.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<close public="1" set="method" line="109" override="1"><f a=""><e path="Void"/></f></close>
		<readBytes public="1" set="method" line="94" override="1"><f a="buf:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<readByte public="1" set="method" line="81" override="1"><f a=""><c path="Int"/></f></readByte>
		<__s><e path="sys.net._Socket.SocketHandle"/></__s>
		<new public="1" set="method" line="77"><f a="s">
	<e path="sys.net._Socket.SocketHandle"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="sys.net.Socket" params="" file="/usr/share/haxe/std/neko/_std/sys/net/Socket.hx">
		<select public="1" set="method" line="214" static="1">
			<f a="read:write:others:?timeout">
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Array"><c path="sys.net.Socket"/></c>
				<c path="Float"/>
				<a>
					<write><c path="Array"><c path="sys.net.Socket"/></c></write>
					<read><c path="Array"><c path="sys.net.Socket"/></c></read>
					<others><c path="Array"><c path="sys.net.Socket"/></c></others>
				</a>
			</f>
			<haxe_doc>Wait until one of the sockets groups is ready for the given operation :
		[read] contains sockets on which we want to wait for available data to be read,
		[write] contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
		[others] contains sockets on which we want to wait for exceptional conditions.
		[select] will block until one of the condition is met, in which case it will return the sockets for which the condition was true.
		In case a [timeout] (in seconds) is specified, select might wait at worse until the timeout expires.</haxe_doc>
		</select>
		<socket_new line="252" static="1"><f a="">
	<e path="Bool"/>
	<e path="sys.net._Socket.SocketHandle"/>
</f></socket_new>
		<socket_close line="253" static="1"><f a="">
	<e path="sys.net._Socket.SocketHandle"/>
	<unknown/>
</f></socket_close>
		<socket_write line="254" static="1"><f a=":">
	<e path="sys.net._Socket.SocketHandle"/>
	<unknown/>
	<unknown/>
</f></socket_write>
		<socket_read line="255" static="1"><f a="">
	<e path="sys.net._Socket.SocketHandle"/>
	<c path="String"/>
</f></socket_read>
		<socket_connect line="256" static="1"><f a="::">
	<e path="sys.net._Socket.SocketHandle"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<unknown/>
</f></socket_connect>
		<socket_listen line="257" static="1"><f a=":">
	<e path="sys.net._Socket.SocketHandle"/>
	<c path="Int"/>
	<unknown/>
</f></socket_listen>
		<socket_select line="258" static="1"><f a=":::">
	<c path="Array"><e path="sys.net._Socket.SocketHandle"/></c>
	<c path="Array"><e path="sys.net._Socket.SocketHandle"/></c>
	<c path="Array"><e path="sys.net._Socket.SocketHandle"/></c>
	<c path="Float"/>
	<c path="Array"><c path="Array"><unknown/></c></c>
</f></socket_select>
		<socket_bind line="259" static="1"><f a="::">
	<e path="sys.net._Socket.SocketHandle"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<unknown/>
</f></socket_bind>
		<socket_accept line="260" static="1"><f a="">
	<e path="sys.net._Socket.SocketHandle"/>
	<e path="sys.net._Socket.SocketHandle"/>
</f></socket_accept>
		<socket_peer line="261" static="1"><f a="">
	<e path="sys.net._Socket.SocketHandle"/>
	<unknown/>
</f></socket_peer>
		<socket_host line="262" static="1"><f a="">
	<e path="sys.net._Socket.SocketHandle"/>
	<unknown/>
</f></socket_host>
		<socket_set_timeout line="263" static="1"><f a=":">
	<e path="sys.net._Socket.SocketHandle"/>
	<c path="Float"/>
	<unknown/>
</f></socket_set_timeout>
		<socket_shutdown line="264" static="1"><f a="::">
	<e path="sys.net._Socket.SocketHandle"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<unknown/>
</f></socket_shutdown>
		<socket_set_blocking line="265" static="1"><f a=":">
	<e path="sys.net._Socket.SocketHandle"/>
	<e path="Bool"/>
	<unknown/>
</f></socket_set_blocking>
		<socket_set_fast_send line="266" static="1"><f a=":">
	<e path="sys.net._Socket.SocketHandle"/>
	<e path="Bool"/>
	<unknown/>
</f></socket_set_fast_send>
		<setFastSend public="1" set="method" line="210">
			<f a="b">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Allows the socket to immediatly send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.</haxe_doc>
		</setFastSend>
		<setBlocking public="1" set="method" line="206">
			<f a="b">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediatly by throwing a haxe.io.Error.Blocking value.</haxe_doc>
		</setBlocking>
		<waitForRead public="1" set="method" line="202">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Block until some data is available for read on the socket.</haxe_doc>
		</waitForRead>
		<setTimeout public="1" set="method" line="198">
			<f a="timeout">
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Gives a timeout after which blocking socket operations (such as reading and writing) will abort and throw an exception.</haxe_doc>
		</setTimeout>
		<host public="1" set="method" line="191">
			<f a=""><a>
	<port><c path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the informations about our side of a connected socket.</haxe_doc>
		</host>
		<peer public="1" set="method" line="184">
			<f a=""><a>
	<port><c path="Int"/></port>
	<host><c path="sys.net.Host"/></host>
</a></f>
			<haxe_doc>Return the informations about the other side of a connected socket.</haxe_doc>
		</peer>
		<accept public="1" set="method" line="175">
			<f a=""><c path="sys.net.Socket"/></f>
			<haxe_doc>Accept a new connected client. This will return a connected socket on which you can read/write some data.</haxe_doc>
		</accept>
		<bind public="1" set="method" line="171">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Bind the socket to the given host/port so it can afterwards listen for connections there.</haxe_doc>
		</bind>
		<shutdown public="1" set="method" line="167">
			<f a="read:write">
				<e path="Bool"/>
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Shutdown the socket, either for reading or writing.</haxe_doc>
		</shutdown>
		<listen public="1" set="method" line="163">
			<f a="connections">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use [accept()] to accept incoming connections.</haxe_doc>
		</listen>
		<connect public="1" set="method" line="152">
			<f a="host:port">
				<c path="sys.net.Host"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Connect to the given server host/port. Throw an exception in case we couldn't sucessfully connect.</haxe_doc>
		</connect>
		<write public="1" set="method" line="148">
			<f a="content">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>Write the whole data to the socket output.</haxe_doc>
		</write>
		<read public="1" set="method" line="144">
			<f a=""><c path="String"/></f>
			<haxe_doc>Read the whole data available on the socket.</haxe_doc>
		</read>
		<close public="1" set="method" line="134">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.</haxe_doc>
		</close>
		<custom public="1">
			<d/>
			<haxe_doc>A custom value that can be associated with the socket. Can be used to retreive your custom infos after a [select].
	*</haxe_doc>
		</custom>
		<output public="1" set="null">
			<c path="haxe.io.Output"/>
			<haxe_doc>The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use [setBlocking(false)] or [setTimeout] to prevent that.</haxe_doc>
		</output>
		<input public="1" set="null">
			<c path="haxe.io.Input"/>
			<haxe_doc>The stream on which you can read available data. By default the stream is blocking until the requested data is available,
		use [setBlocking(false)] or [setTimeout] to prevent infinite waiting.</haxe_doc>
		</input>
		<__s><e path="sys.net._Socket.SocketHandle"/></__s>
		<new public="1" set="method" line="128">
			<f a=""><e path="Void"/></f>
			<haxe_doc>Creates a new unconnected socket.</haxe_doc>
		</new>
		<haxe_doc>A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.</haxe_doc>
		<meta><m n=":core_api"/></meta>
	</class>
</haxe>