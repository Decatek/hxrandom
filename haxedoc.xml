<haxe>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<filter public="1" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<map public="1" params="S" set="method">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.
		
		The order of elements is preserved.
		
		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.
		
		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However, 
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurence of `x` in `this` Array.
		
		This operation modifies `this` Array in place.
		
		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed acoordingly. The function
		then returns true.
		
		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.
		
		This operation modifies `this` Array in place.
		
		The offset is calculated like so:
			
		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this` 
		  Array, i.e. `this.length + pos`. If this yields a negative value, the 
		  offset is 0.
		- Otherwise, the offset is `pos`.
		
		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.
		
		This operation modifies `this` Array in place.
		
		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.
		
		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use Std.string() to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.
		
		This operation modifies `this` Array in place.
		
		If `len` is < 0 or `pos` exceeds `this`.length, the result is the empty
		Array [].
		
		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.
		
		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.
		
		This operation modifies `this` Array in place.
		
		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.sort.MergeSort.sort()` can be used instead.
		
		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.
		
		This operation does not modify `this` Array.
		
		The elements are not copied and retain their identity.
		
		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.
		
		If `pos` or `end` are negative, their offsets are calculated from the
		end	of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.
		
		If `pos` exceeds `this.length` or if `end` exceeds or equals `pos`,
		the result is `[]`.</haxe_doc>
		</slice>
		<shift public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.
		
		If `this` is the empty Array `[]`, `null` is returned and the length 
		remains 0.</haxe_doc>
		</shift>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.
		
		This operation modifies `this` Array in place.
		
		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the offset
		it was added at.
		
		This operation modifies `this` Array in place.
		
		`this.length` increases by 1.</haxe_doc>
		</push>
		<pop public="1" set="method">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.
		
		This operation modifies `this` Array in place.
		
		If `this` has at least one element, `this.length` will decrease by 1.
		
		If `this` is the empty Array `[]`, null is returned and the length 
		remains 0.</haxe_doc>
		</pop>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.
		
		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`
		
		If `this` is the empty Array `[]`, the result is the empty String `""`. 
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.
		
		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.
		
		This operation does not modify `this` Array.
		
		If `a` is the empty Array `[]`, a copy of `this` Array is returned.
		
		The length of the returned Array is equal to the sum of `this.length` 
		and `a.length`.
		
		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a `List` which
	is less memory and CPU consuming, unless you really need indexed access.</haxe_doc>
	</class>
	<abstract path="Class" params="T" file="/usr/lib/haxe/std/Class.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents a Class.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/usr/lib/haxe/std/Date.hx" extern="1">
		<now public="1" set="method" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" set="method" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:
		
		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`
		
		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.
		
		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.
		
		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by
	
	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.
	
	There is some extra functions available in the `DateTools` class.
	
	In the context of haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
	</class>
	<class path="EReg" params="" file="/usr/lib/haxe/std/flash/_std/EReg.hx">
		<matchedRight public="1" set="method" line="47">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.
		
		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.
		
		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.
		
		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matched public="1" set="method" line="37">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.
		
		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.
		
		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, an exception is thrown.
		
		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<match public="1" set="method" line="31">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.
		
		This method modifies the internal state.
		
		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<result><c path="+Array"/></result>
		<r><c path="flash.utils.RegExp"/></r>
		<new public="1" set="method" line="27">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.
		
		This is equivalent to the shorthand syntax `~/r/opt`
		
		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc>The EReg class represents regular expressions.
	
	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.
	
	EReg instances can be created by calling the constructor, or with the
	special syntax ~/pattern/modifier
	
	EReg instances maintain an internal state, which is affected by several of
	its methods.
	
	A detailed explanation of the supported operations is available at
	http://haxe.org/doc/cross/regexp</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/lib/haxe/std/Enum.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents an Enum type.
	
	The corresponding enum instance type is `EnumValue`.
	
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/lib/haxe/std/EnumValue.hx">
		<this><d/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Lambda" params="" file="/usr/lib/haxe/std/Lambda.hx">
		<filter public="1" params="A" set="method" line="159" static="1">
			<f a="it:f">
				<t path="Iterable"><c path="filter.A"/></t>
				<f a="">
					<c path="filter.A"/>
					<x path="Bool"/>
				</f>
				<c path="List"><c path="filter.A"/></c>
			</f>
			<haxe_doc>Returns a List containing those elements of `it` for which `f` returned
		true.
		
		If `it` is empty, the result is the empty List even if `f` is null.
		
		Otherwise if `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<haxe_doc>The `Lambda` class is a collection of methods to support functional
	programming. It is ideally used with 'using Lambda' and then acts as an
	extension to Iterable types.
	
	On static platforms, working with the Iterable structure might be slower
	than performing the operations directly on known types, such as Array and
	List.
	
	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<iterator public="1" set="method" line="161">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>Returns an iterator on the elements of the list.</haxe_doc>
		</iterator>
		<add public="1" set="method" line="49">
			<f a="item">
				<c path="List.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds element `item` at the end of `this` List.
		
		`this.length` increases by 1.</haxe_doc>
		</add>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` List.</haxe_doc>
		</length>
		<q><c path="Array"><d/></c></q>
		<h><c path="Array"><d/></c></h>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new empty list.</haxe_doc>
		</new>
		<haxe_doc>A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It is optimized so that adding or removing an
	element does not imply copying the whole array content every time.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="Map" params="K:V" file="/usr/lib/haxe/std/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="IMap">
	<c path="Map.K"/>
	<c path="Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="Map.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="Map.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="Map.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="Map.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.
		
	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.
	
	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.
	
	Maps can also be created with `key1 => value1, key2 => value2` syntax.
	
	Map is an abstract type, it is not available at runtime.]]></haxe_doc>
		<meta><m n=":multiType"/></meta>
		<impl><class path="_Map.Map_Impl_" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="IMap" params="K:V" file="/usr/lib/haxe/std/Map.hx" module="Map" interface="1"><meta><m n=":keep"/></meta></class>
	<typedef path="_Map.Hashable" params="" file="/usr/lib/haxe/std/Map.hx" private="1" module="Map"><a><hashCode set="method"><f a=""><x path="Int"/></f></hashCode></a></typedef>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><x path="Float"/></PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of -1.0 / 0.0.
		
		Operations with NEGATIVE_INFINITY as an operand may result in
		Operations with NEGATIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes negative infinity.
		
		For example, this is the result of 1.0 / 0.0.
		
		Operations with POSITIVE_INFINITY as an operand may result in
		NEGATIVE_INFINITY, POSITIVE_INFINITY or NaN. For detailed information,
		see ...
	
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special Float constant which denotes an invalid number.
		
		NaN stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: Math.sqrt(-1).
		
		All further operations with NaN as an operand will result in NaN.
		
		If this constant is converted to an Int, e.g. through Std.int(), the
		result is unspecified.
		
		In order to test if a value is NaN, you should use Math.isNaN() function.
		
		(Php) In PHP versions prior to 5.3.1 VC 9 there may be unexpected
		results when performing arithmetic operations with NaN on Windows, see:
			https://bugs.php.net/bug.php?id=42143</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.
		
		If `v` is positive or 0, the result is unchanged. Otherwise the result
		is -`v`.
		
		If `v` is NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is
		POSITIVE_INFINITY.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.
		
		If `a` and `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.
		
		If `a` or `b` are NaN, the result is NaN.
		
		If `a` or `b` are POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `a` and `b` are NEGATIVE_INFINITY, the result is NEGATIVE_INFINITY.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of `v`.
		
		The unit of `v` is radians.
		
		If `v` is NaN or infinite, the result is NaN.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></tan>
		<asin public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></asin>
		<acos public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></acos>
		<atan public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></atan>
		<atan2 public="1" set="method" static="1"><f a="y:x">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.
		
		exp(1.0) is approximately 2.718281828459.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is NEGATIVE_INFINITY, the result is 0.0.
		
		If `v` is NaN, the result is NaN.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is NEGATIVE_INFINITY.
		
		This is the inverse operation of exp, i.e. log(exp(v)) == v always
		holds.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1"><f a="v:exp">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.
		
		If `v` is negative (including NEGATIVE_INFINITY) or NaN, the result is
		NaN.
		
		If `v` is POSITIVE_INFINITY, the result is POSITIVE_INFINITY.
		
		If `v` is 0.0, the result is 0.0.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest Int value.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest Int value that is not greater than `v`.
		
		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.		
		
		TODO: need spec</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest Int value that is not less than `v`.

		If v is outside of the signed Int32 range, or is NaN, NEGATIVE_INFINITY or POSITIVE_INFINITY, the result is unspecified.
		
		TODO: need spec</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to 0.0,
		and less than 1.0.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></ffloor>
		<fceil public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fceil>
		<fround public="1" set="method" static="1"><f a="v">
	<x path="Float"/>
	<x path="Float"/>
</f></fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.
		
		If `f` is POSITIVE_INFINITY, NEGATIVE_INFINITY or NaN, the result is
		false.
		
		Otherwise the result is true.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.
		
		If `f` is NaN, the result is true.
		
		Otherwise the result is false. In particular, both POSITIVE_INFINITY and
		NEGATIVE_INFINITY are not considered NaN.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.</haxe_doc>
	</class>
	<class path="Random" params="" file="src/Random.hx">
		<bool public="1" get="inline" set="null" line="15" static="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Return a random boolean value (true or false)</haxe_doc>
		</bool>
		<int public="1" get="inline" set="null" line="21" static="1">
			<f a="from:to">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Return a random integer between 'from' and 'to', inclusive.</haxe_doc>
		</int>
		<float public="1" get="inline" set="null" line="27" static="1">
			<f a="from:to">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Return a random float between 'from' and 'to', inclusive.</haxe_doc>
		</float>
		<string public="1" set="method" line="34" static="1">
			<f a="length:?charactersToUse">
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Return a random string of a certain length.  You can optionally specify 
	    which characters to use, otherwise the default is (a-zA-Z0-9)</haxe_doc>
		</string>
		<fromArray public="1" params="T" get="inline" set="null" line="45" static="1">
			<f a="arr">
				<c path="Array"><c path="fromArray.T"/></c>
				<t path="Null"><c path="fromArray.T"/></t>
			</f>
			<haxe_doc>Return a random item from an array.  Will return null if the array is null or empty.</haxe_doc>
		</fromArray>
		<enumConstructor public="1" params="T" get="inline" set="null" line="51" static="1">
			<f a="e">
				<x path="Enum"><c path="enumConstructor.T"/></x>
				<t path="Null"><c path="enumConstructor.T"/></t>
			</f>
			<haxe_doc>Return a random constructor from an Enum.  Will return null if the enum has no constructors. Only works with enum constructors that take no parameters.</haxe_doc>
		</enumConstructor>
		<haxe_doc>**
* Copyright (c) 2013 Jason O'Neil
* 
* Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
* 
* The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* 
**</haxe_doc>
	</class>
	<class path="RandomTest" params="" file="test/RandomTest.hx">
		<enumConstructorNull public="1" set="method" line="266">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</enumConstructorNull>
		<enumConstructorWithParams public="1" set="method" line="259">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</enumConstructorWithParams>
		<enumConstructorNone public="1" set="method" line="252">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</enumConstructorNone>
		<enumConstructor public="1" set="method" line="237">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</enumConstructor>
		<arrayNull public="1" set="method" line="230">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</arrayNull>
		<arrayEmpty public="1" set="method" line="223">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</arrayEmpty>
		<arrayOfInts public="1" set="method" line="203">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</arrayOfInts>
		<arrayOfStrings public="1" set="method" line="183">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</arrayOfStrings>
		<stringWithCustomRange public="1" set="method" line="166">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</stringWithCustomRange>
		<string public="1" set="method" line="149">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</string>
		<bool public="1" set="method" line="138">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</bool>
		<floatInclusive public="1" set="method" line="131">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</floatInclusive>
		<floatDecimal public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</floatDecimal>
		<floatNegativeAndPositive public="1" set="method" line="107">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</floatNegativeAndPositive>
		<floatNegative public="1" set="method" line="95">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</floatNegative>
		<float public="1" set="method" line="83">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</float>
		<intInclusive public="1" set="method" line="76">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</intInclusive>
		<intNegativeAndPositive public="1" set="method" line="64">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</intNegativeAndPositive>
		<intNegative public="1" set="method" line="52">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</intNegative>
		<int public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<meta><m n="Test"/></meta>
		</int>
		<tearDown public="1" set="method" line="34">
			<f a=""><x path="Void"/></f>
			<meta><m n="After"/></meta>
		</tearDown>
		<setup public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<meta><m n="Before"/></meta>
		</setup>
		<afterClass public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<meta><m n="AfterClass"/></meta>
		</afterClass>
		<beforeClass public="1" set="method" line="19">
			<f a=""><x path="Void"/></f>
			<meta><m n="BeforeClass"/></meta>
		</beforeClass>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Auto generated ExampleTest for MassiveUnit. 
* This is an example test class can be used as a template for writing normal and async tests 
* Refer to munit command line tool for more information (haxelib run munit)</haxe_doc>
	</class>
	<enum path="Color" params="" file="test/RandomTest.hx" module="RandomTest">
		<Red/>
		<Blue/>
		<Green/>
	</enum>
	<enum path="EnumNone" params="" file="test/RandomTest.hx" module="RandomTest"/>
	<enum path="EnumWithParams" params="" file="test/RandomTest.hx" module="RandomTest">
		<Something a="a"><c path="String"/></Something>
		<Else a="b"><x path="Int"/></Else>
	</enum>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/flash/_std/Reflect.hx">
		<hasField public="1" set="method" line="24" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.
		
		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" line="28" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.
		
		If `o` is not an object or has no field named `field`, the result is
		null.
		
		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.
		
		If `field` is null, the result is unspecified.
		
		(As3) If used on a property field, the getter will be invoked. It is
		not possible to obtain the value directly.</haxe_doc>
		</field>
		<fields public="1" set="method" line="59" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.
		
		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.
		
		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" line="82" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.
		
		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<deleteField public="1" set="method" line="114" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.
		
		This method is only guaranteed to work on anonymous structures.
		
		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<makeVarArgs public="1" set="method" line="128" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method"><f a="f">
	<f a="">
		<c path="Array"><d/></c>
		<x path="Void"/>
	</f>
	<d/>
</f></makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/flash/_std/Std.hx">
		<is public="1" set="method" line="26" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value v is of the type t. Returns false if v or t are null.</haxe_doc>
		</is>
		<string public="1" set="method" line="34" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<parseInt public="1" set="method" line="42" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If the input cannot be recognized, the result is null.</haxe_doc>
		</parseInt>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>The standard Void type. Only `null` values can be of the type `Void`.</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Float type, this is a double-precision IEEE 64bit float.
	
	On static targets, null cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard Int type. Its precision depends on the platform.
	
	On static targets, null cannot be assigned to Int. If this is necessary,
	`Null<Int>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><x path="Int"/></icast></from>
		<this><d/></this>
		<to><icast><x path="Int"/></icast></to>
		<haxe_doc>The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accepts or can return a `null` value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be true or false.
	
	On static targets, null cannot be assigned to Bool. If this is necessary,
	`Null<Bool>` can be used instead.]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<this><d/></this>
		<haxe_doc>Dynamic is a special type which is compatible with all other types.
	
	Use of Dynamic should be minimized as it prevents several compiler
	checks and optimizations.</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the Iterator and advances to the next one.
		
		This method is not required to check hasNext() first. A call to this
		method while hasNext() is false yields unspecified behavior.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns false if the iteration is complete, true otherwise.
		
		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to next(). However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An Iterator is a structure that permits iteration over elements of type T.

	Any class with matching hasNext and next fields is considered an Iterator
	and can then be used e.g. in for-loops. This makes it easy to implement
	custom iterators.</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An Iterable is a data structure which has an iterator() method.
	See `Lambda` for generic functions on iterable structures.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.</haxe_doc></class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.
		
		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to `endIndex`.
		
		If `startIndex` or `endIndex` are negative, 0 is used instead.
		
		If `startIndex` exceeds `endIndex`, they are swapped.
		
		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.
		
		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String "" is returned.</haxe_doc>
		</substring>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.
		
		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.
		
		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.
		
		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.
		
		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.
		
		If `delimiter` is the empty String "", `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.
		
		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.
		
		If `delimiter` is null, the result is unspecified.
		
		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with [delimiter}, the
		result Array contains a leading (or trailing) empty String "" element.
		Two subsequent delimiters also result in an empty String "" element.</haxe_doc>
		</split>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.
		
		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.
		
		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, null is returned.
		
		To obtain the character code of a single character, "x".code can be used
		instead to inline the character code at compile time. Note that this
		only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.
		
		If `index` is negative or exceeds `this.length`, the empty String ""
		is returned.</haxe_doc>
		</charAt>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.
		
		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.
		
		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.
	
	A haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.
	
	Strings can be constructed using the string literal syntax "string value".
	
	String can be concatenated by using the + operator. If an operand is not a
	String, it is passed through Std.string() first.</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<b><c path="String"/></b>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.
		
		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.
	
	Its cross-platform implementation uses String concatenation internally, but
	StringBuf may be optimized for different targets.
	
	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values. However, the internal buffer cannot be modified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<htmlEscape public="1" set="method" line="98" static="1">
			<f a="s:?quotes">
				<c path="String"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc><![CDATA[Escapes HTML special characters of the string `s`.

		The following replacements are made:
			
		- `&` becomes `&amp`;
		- `<` becomes `&lt`;
		- `>` becomes `&gt`;
		
		If `quotes` is true, the following characters are also replaced:
		
		- `"` becomes `&quot`;
		- `'` becomes `&#039`;]]></haxe_doc>
		</htmlEscape>
		<lpad public="1" set="method" line="249" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Concatenates `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String "" or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</lpad>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	'using StringTools' and then acts as an extension to the String class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="TestMain" params="" file="test/TestMain.hx">
		<main set="method" line="18" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<completionHandler set="method" line="45"><f a="successful">
	<x path="Bool"/>
	<x path="Void"/>
</f></completionHandler>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Auto generated Test Application.
 * Refer to munit command line tool for more information (haxelib run munit)</haxe_doc>
	</class>
	<class path="massive.munit.TestSuite" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/TestSuite.hx">
		<sortByName set="method" line="120"><f a="x:y">
	<x path="Class"><d/></x>
	<x path="Class"><d/></x>
	<x path="Int"/>
</f></sortByName>
		<sortTests set="method" line="115"><f a=""><x path="Void"/></f></sortTests>
		<repeat public="1" set="method" line="110">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[* Drop the iterator back one so next call to <code>next()</code> will return the
	 * same test class again.]]></haxe_doc>
		</repeat>
		<next public="1" set="method" line="101">
			<f a=""><x path="Class"><d/></x></f>
			<haxe_doc>* Get the next test class in this iterable suite of test classes.
	 * 
	 * @return	the next test class in the suite, or null if no more classes available</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="91">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check to see if there is another test class in this iterable suite of test classes.
	 * 
	 * @return	true if there is another test class, false if not</haxe_doc>
		</hasNext>
		<add public="1" set="method" line="80">
			<f a="test">
				<x path="Class"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add a class which contains test methods.
	 * 
	 * @param	test			a class containing methods which execute tests</haxe_doc>
		</add>
		<index><x path="Int"/></index>
		<tests><c path="Array"><d/></c></tests>
		<new public="1" set="method" line="69">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Class constructor.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Iterable (http://haxe.org/ref/iterators) suite of test classes.
 * <p>
 * Each class added to a test suite should contain one or more meta tagged methods which execute unit tests.
 * </p>
 * <pre>
 * class MathUtilTest
 * {
 *     @Test
 *     public function testAdd():Void
 *     {
 *         Assert.areEqual(2, MathUtil.add(1,1));
 *     }
 * }
 * 
 * class TestSuite extends massive.unit.TestSuite
 * {
 *     public function new()
 *     {
 *          add(MathUtilTest);
 *     }
 * }
 * </pre>
 * @author Mike Stead]]></haxe_doc>
	</class>
	<class path="TestSuite" params="" file="test/TestSuite.hx">
		<extends path="massive.munit.TestSuite"/>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Auto generated Test Suite for MassiveUnit.
 * Refer to munit command line tool for more information (haxelib run munit)</haxe_doc>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx" module="Type">
		<TNull/>
		<TInt/>
		<TFloat/>
		<TBool/>
		<TObject/>
		<TFunction/>
		<TClass a="c"><x path="Class"><d/></x></TClass>
		<TEnum a="e"><x path="Enum"><d/></x></TEnum>
		<TUnknown/>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/flash/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="36" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.
		
		If `o` is null or of a different type, null is returned.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getSuperClass public="1" set="method" line="62" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.
		
		If `c` has no super class, null is returned.
		
		If `c` is null, the result is unspecified.
		
		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" line="69" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.
		
		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `c` has no package, the class name is returned.
		
		If `c` is null, the result is unspecified.
		
		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<createInstance public="1" params="T" set="method" line="130" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.
		
		This function guarantees that the class constructor is called.
		
		Default values of constructors arguments are not guaranteed to be
		taken into account.
		
		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.
		
		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" line="151" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.
		
		This function guarantees that the class constructor is not called.
		
		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<typeof public="1" set="method" line="215" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.
		
		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" line="247" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<allEnums public="1" params="T" set="method" line="276" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The haxe Reflection API allows retrieval of type information at runtime.
	
	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/IEventDispatcher.hx" extern="1" interface="1">
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<willTrigger public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></willTrigger>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<removeEventListener public="1" set="method"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Void"/>
</f></removeEventListener>
		<hasEventListener public="1" set="method"><f a="type">
	<c path="String"/>
	<x path="Bool"/>
</f></hasEventListener>
		<dispatchEvent public="1" set="method"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Bool"/>
</f></dispatchEvent>
		<addEventListener public="1" set="method"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></addEventListener>
		<new public="1" set="method"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<localToGlobal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
		<hitTestPoint public="1" set="method"><f a="x:y:?shapeFlag">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></hitTestPoint>
		<hitTestObject public="1" set="method"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></hitTestObject>
		<globalToLocal public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<getRect public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<getBounds public="1" set="method"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<visible public="1"><x path="Bool"/></visible>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<scaleY public="1"><x path="Float"/></scaleY>
		<scaleX public="1"><x path="Float"/></scaleX>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<rotation public="1"><x path="Float"/></rotation>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<opaqueBackground public="1"><t path="Null"><x path="UInt"/></t></opaqueBackground>
		<name public="1"><c path="String"/></name>
		<mouseY public="1" set="null"><x path="Float"/></mouseY>
		<mouseX public="1" set="null"><x path="Float"/></mouseX>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<height public="1"><x path="Float"/></height>
		<filters public="1"><c path="Array"><c path="flash.filters.BitmapFilter"/></c></filters>
		<cacheAsBitmap public="1"><x path="Bool"/></cacheAsBitmap>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<alpha public="1"><x path="Float"/></alpha>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<tabIndex public="1"><x path="Int"/></tabIndex>
		<tabEnabled public="1"><x path="Bool"/></tabEnabled>
		<mouseEnabled public="1"><x path="Bool"/></mouseEnabled>
		<focusRect public="1"><d/></focusRect>
		<doubleClickEnabled public="1"><x path="Bool"/></doubleClickEnabled>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<swapChildrenAt public="1" set="method"><f a="index1:index2">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></swapChildrenAt>
		<swapChildren public="1" set="method"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></swapChildren>
		<setChildIndex public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setChildIndex>
		<removeChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<removeChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<getObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<getChildIndex public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
</f></getChildIndex>
		<getChildByName public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildAt public="1" set="method"><f a="index">
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<contains public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<x path="Bool"/>
</f></contains>
		<areInaccessibleObjectsUnderPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<addChildAt public="1" set="method"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<x path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<addChild public="1" set="method"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<tabChildren public="1"><x path="Bool"/></tabChildren>
		<numChildren public="1" set="null"><x path="Int"/></numChildren>
		<mouseChildren public="1"><x path="Bool"/></mouseChildren>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<stopDrag public="1" set="method"><f a=""><x path="Void"/></f></stopDrag>
		<startDrag public="1" set="method"><f a="?lockCenter:?bounds">
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></startDrag>
		<useHandCursor public="1"><x path="Bool"/></useHandCursor>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<buttonMode public="1"><x path="Bool"/></buttonMode>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<stop public="1" set="method"><f a=""><x path="Void"/></f></stop>
		<prevScene public="1" set="method"><f a=""><x path="Void"/></f></prevScene>
		<prevFrame public="1" set="method"><f a=""><x path="Void"/></f></prevFrame>
		<play public="1" set="method"><f a=""><x path="Void"/></f></play>
		<nextScene public="1" set="method"><f a=""><x path="Void"/></f></nextScene>
		<nextFrame public="1" set="method"><f a=""><x path="Void"/></f></nextFrame>
		<gotoAndStop public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndStop>
		<gotoAndPlay public="1" set="method"><f a="frame:?scene">
	<t path="flash.utils.Object"/>
	<c path="String"/>
	<x path="Void"/>
</f></gotoAndPlay>
		<addFrameScript public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></addFrameScript>
		<trackAsMenu public="1"><x path="Bool"/></trackAsMenu>
		<totalFrames public="1" set="null"><x path="Int"/></totalFrames>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<framesLoaded public="1" set="null"><x path="Int"/></framesLoaded>
		<enabled public="1"><x path="Bool"/></enabled>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentFrame public="1" set="null"><x path="Int"/></currentFrame>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.errors.Error"/></lastError>
		<skip_constructor public="1" line="51" static="1"><x path="Bool"/></skip_constructor>
		<enum_to_string public="1" set="method" line="83" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" set="method" line="92" static="1"><f a="v:t">
	<d/>
	<d/>
	<x path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" set="method" line="102" static="1"><f a=""><x path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" set="method" line="110" static="1"><f a="rgb">
	<x path="UInt"/>
	<x path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" set="method" line="116" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" set="method" line="144" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></__trace>
		<__string_rec public="1" set="method" line="163" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ set="method" line="208" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<init set="method" line="79"><f a=""><x path="Void"/></f></init>
		<doInitDelay set="method" line="74"><f a="_">
	<unknown/>
	<x path="Void"/>
</f></doInitDelay>
		<start set="method" line="53"><f a=""><x path="Void"/></f></start>
		<new public="1" set="method" line="45"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash._Boot.RealBoot" params="" file="/usr/lib/haxe/std/flash/Boot.hx" private="1" module="flash.Boot">
		<extends path="flash.Boot"/>
		<new set="method" line="35"><f a=""><x path="Void"/></f></new>
		<meta><m n=":keep"/></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="flash.Vector" params="T" file="/usr/lib/haxe/std/flash/Vector.hx" extern="1">
		<lastIndexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></lastIndexOf>
		<indexOf public="1" set="method"><f a="x:?from">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOf>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<splice public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></splice>
		<sort public="1" set="method"><f a="f">
	<f a=":">
		<c path="flash.Vector.T"/>
		<c path="flash.Vector.T"/>
		<x path="Int"/>
	</f>
	<x path="Void"/>
</f></sort>
		<slice public="1" set="method"><f a="?pos:?end">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></slice>
		<unshift public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Void"/>
</f></unshift>
		<shift public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></shift>
		<reverse public="1" set="method"><f a=""><x path="Void"/></f></reverse>
		<push public="1" set="method"><f a="x">
	<c path="flash.Vector.T"/>
	<x path="Int"/>
</f></push>
		<pop public="1" set="method"><f a=""><t path="Null"><c path="flash.Vector.T"/></t></f></pop>
		<join public="1" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<concat public="1" set="method"><f a="?a">
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
	<c path="flash.Vector"><c path="flash.Vector.T"/></c>
</f></concat>
		<fixed public="1"><x path="Bool"/></fixed>
		<length public="1"><x path="Int"/></length>
		<new public="1"><f a="?length:?fixed">
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>The Vector class is very similar to Array but is only supported by the Flash Player 10+</haxe_doc>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityImplementation.hx" extern="1">
		<isLabeledBy public="1" set="method"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></isLabeledBy>
		<get_selectionAnchorIndex public="1" set="method"><f a=""><d/></f></get_selectionAnchorIndex>
		<get_selectionActiveIndex public="1" set="method"><f a=""><d/></f></get_selectionActiveIndex>
		<get_accValue public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<get_accState public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accState>
		<get_accSelection public="1" set="method"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accRole public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="UInt"/>
</f></get_accRole>
		<get_accName public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accFocus public="1" set="method"><f a=""><x path="UInt"/></f></get_accFocus>
		<get_accDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<getChildIDArray public="1" set="method"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<accSelect public="1" set="method"><f a="operation:childID">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></accSelect>
		<accLocation public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<d/>
</f></accLocation>
		<accDoDefaultAction public="1" set="method"><f a="childID">
	<x path="UInt"/>
	<x path="Void"/>
</f></accDoDefaultAction>
		<stub public="1"><x path="Bool"/></stub>
		<errno public="1"><x path="UInt"/></errno>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash/accessibility/AccessibilityProperties.hx" extern="1">
		<silent public="1"><x path="Bool"/></silent>
		<shortcut public="1"><c path="String"/></shortcut>
		<noAutoLabeling public="1"><x path="Bool"/></noAutoLabeling>
		<name public="1"><c path="String"/></name>
		<forceSimple public="1"><x path="Bool"/></forceSimple>
		<description public="1"><c path="String"/></description>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT2/>
		<ACTIONSCRIPT3/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<unlock public="1" set="method"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></unlock>
		<threshold public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="UInt"/>
</f></threshold>
		<setPixels public="1" set="method"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></setPixels>
		<setPixel32 public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel32>
		<setPixel public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setPixel>
		<scroll public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<pixelDissolve public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Int"/>
</f></pixelDissolve>
		<perlinNoise public="1" set="method"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<x path="Float"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<x path="Void"/>
</f></perlinNoise>
		<paletteMap public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<c path="Array"><x path="Int"/></c>
	<x path="Void"/>
</f></paletteMap>
		<noise public="1" set="method"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<x path="Int"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></noise>
		<merge public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></merge>
		<lock public="1" set="method"><f a=""><x path="Void"/></f></lock>
		<hitTest public="1" set="method"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<t path="flash.utils.Object"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="Bool"/>
</f></hitTest>
		<getPixels public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<getPixel32 public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel32>
		<getPixel public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
</f></getPixel>
		<getColorBoundsRect public="1" set="method"><f a="mask:color:?findColor">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<generateFilterRect public="1" set="method"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<floodFill public="1" set="method"><f a="x:y:color">
	<x path="Int"/>
	<x path="Int"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></floodFill>
		<fillRect public="1" set="method"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></fillRect>
		<draw public="1" set="method"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></draw>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<copyPixels public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></copyPixels>
		<copyChannel public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></copyChannel>
		<compare public="1" set="method"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<t path="flash.utils.Object"/>
</f></compare>
		<colorTransform public="1" set="method"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></colorTransform>
		<clone public="1" set="method"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<applyFilter public="1" set="method"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<x path="Void"/>
</f></applyFilter>
		<width public="1" set="null"><x path="Int"/></width>
		<transparent public="1" set="null"><x path="Bool"/></transparent>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<height public="1" set="null"><x path="Int"/></height>
		<new public="1" set="method"><f a="width:height:?transparent:?fillColor">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash/display/BlendMode.hx">
		<ADD/>
		<ALPHA/>
		<DARKEN/>
		<DIFFERENCE/>
		<ERASE/>
		<HARDLIGHT/>
		<INVERT/>
		<LAYER/>
		<LIGHTEN/>
		<MULTIPLY/>
		<NORMAL/>
		<OVERLAY/>
		<SCREEN/>
		<SHADER/>
		<SUBTRACT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash/display/CapsStyle.hx">
		<NONE/>
		<ROUND/>
		<SQUARE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.ColorCorrection" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrection.hx">
		<DEFAULT/>
		<OFF/>
		<ON/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<enum path="flash.display.ColorCorrectionSupport" params="" file="/usr/lib/haxe/std/flash/display/ColorCorrectionSupport.hx">
		<DEFAULT_OFF/>
		<DEFAULT_ON/>
		<UNSUPPORTED/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</enum>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash/display/FrameLabel.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<name public="1" set="null"><c path="String"/></name>
		<frame public="1" set="null"><x path="Int"/></frame>
		<new public="1" set="method"><f a="name:frame">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash/display/GradientType.hx">
		<LINEAR/>
		<RADIAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/std/flash/display/Graphics.hx" extern="1">
		<moveTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></moveTo>
		<lineTo public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineTo>
		<lineStyle public="1" set="method"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineStyle>
		<lineGradientStyle public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></lineGradientStyle>
		<endFill public="1" set="method"><f a=""><x path="Void"/></f></endFill>
		<drawRoundRectComplex public="1" set="method"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRectComplex>
		<drawRoundRect public="1" set="method"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRoundRect>
		<drawRect public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawRect>
		<drawEllipse public="1" set="method"><f a="x:y:width:height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawEllipse>
		<drawCircle public="1" set="method"><f a="x:y:radius">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></drawCircle>
		<curveTo public="1" set="method"><f a="controlX:controlY:anchorX:anchorY">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></curveTo>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<beginGradientFill public="1" set="method"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><x path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginGradientFill>
		<beginFill public="1" set="method"><f a="color:?alpha">
	<x path="UInt"/>
	<x path="Float"/>
	<x path="Void"/>
</f></beginFill>
		<beginBitmapFill public="1" set="method"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></beginBitmapFill>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display.GraphicsPathWinding" params="" file="/usr/lib/haxe/std/flash/display/GraphicsPathWinding.hx">
		<EVEN_ODD/>
		<NON_ZERO/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.IGraphicsData" params="" file="/usr/lib/haxe/std/flash/display/IGraphicsData.hx" extern="1" interface="1"/>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash/display/InterpolationMethod.hx">
		<LINEAR_RGB/>
		<RGB/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash/display/JointStyle.hx">
		<BEVEL/>
		<MITER/>
		<ROUND/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash/display/LineScaleMode.hx">
		<HORIZONTAL/>
		<NONE/>
		<NORMAL/>
		<VERTICAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<unload public="1" set="method"><f a=""><x path="Void"/></f></unload>
		<loadBytes public="1" set="method"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></loadBytes>
		<load public="1" set="method"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<x path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" set="method" static="1"><f a="object">
	<d/>
	<c path="flash.display.LoaderInfo"/>
</f></getLoaderInfoByDefinition>
		<width public="1" set="null"><x path="Int"/></width>
		<url public="1" set="null"><c path="String"/></url>
		<swfVersion public="1" set="null"><x path="UInt"/></swfVersion>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<sameDomain public="1" set="null"><x path="Bool"/></sameDomain>
		<parentAllowsChild public="1" set="null"><x path="Bool"/></parentAllowsChild>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<height public="1" set="null"><x path="Int"/></height>
		<frameRate public="1" set="null"><x path="Float"/></frameRate>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<childAllowsParent public="1" set="null"><x path="Bool"/></childAllowsParent>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bytes public="1" set="null"><c path="flash.utils.ByteArray"/></bytes>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
	</class>
	<class path="flash.display.NativeMenu" params="" file="/usr/lib/haxe/std/flash/display/NativeMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash/display/Scene.hx" extern="1">
		<numFrames public="1" set="null"><x path="Int"/></numFrames>
		<name public="1" set="null"><c path="String"/></name>
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<new public="1" set="method"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display.Shader" params="" file="/usr/lib/haxe/std/flash/display/Shader.hx" extern="1">
		<precisionHint public="1"><e path="flash.display.ShaderPrecision"/></precisionHint>
		<data public="1"><c path="flash.display.ShaderData"/></data>
		<byteCode public="1" get="null"><c path="flash.utils.ByteArray"/></byteCode>
		<new public="1"><f a="?code">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.display.ShaderData" params="" file="/usr/lib/haxe/std/flash/display/ShaderData.hx" extern="1">
		<new public="1" set="method"><f a="byteCode">
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.ShaderPrecision" params="" file="/usr/lib/haxe/std/flash/display/ShaderPrecision.hx">
		<FAST/>
		<FULL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash/display/SpreadMethod.hx">
		<PAD/>
		<REFLECT/>
		<REPEAT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<isFocusInaccessible public="1" set="method"><f a=""><x path="Bool"/></f></isFocusInaccessible>
		<invalidate public="1" set="method"><f a=""><x path="Void"/></f></invalidate>
		<stageWidth public="1"><x path="Int"/></stageWidth>
		<stageHeight public="1"><x path="Int"/></stageHeight>
		<stageFocusRect public="1"><x path="Bool"/></stageFocusRect>
		<showDefaultContextMenu public="1"><x path="Bool"/></showDefaultContextMenu>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<fullScreenWidth public="1" set="null"><x path="UInt"/></fullScreenWidth>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenHeight public="1" set="null"><x path="UInt"/></fullScreenHeight>
		<frameRate public="1"><x path="Float"/></frameRate>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<align public="1"><e path="flash.display.StageAlign"/></align>
	</class>
	<class path="flash.display.Stage3D" params="" file="/usr/lib/haxe/std/flash/display/Stage3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<requestContext3D public="1" set="method"><f a="?context3DRenderMode:?profile">
	<c path="String"/>
	<e path="flash.display3D.Context3DProfile"/>
	<x path="Void"/>
</f></requestContext3D>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<visible public="1"><x path="Bool"/></visible>
		<context3D public="1" set="null"><c path="flash.display3D.Context3D"/></context3D>
		<meta><m n=":require"><e>flash11</e></m></meta>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash/display/StageAlign.hx">
		<BOTTOM/>
		<BOTTOM_LEFT/>
		<BOTTOM_RIGHT/>
		<LEFT/>
		<RIGHT/>
		<TOP/>
		<TOP_LEFT/>
		<TOP_RIGHT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash/display/StageDisplayState.hx">
		<FULL_SCREEN/>
		<FULL_SCREEN_INTERACTIVE/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash/display/StageQuality.hx">
		<BEST/>
		<HIGH/>
		<HIGH_16X16/>
		<HIGH_16X16_LINEAR/>
		<HIGH_8X8/>
		<HIGH_8X8_LINEAR/>
		<LOW/>
		<MEDIUM/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash/display/StageScaleMode.hx">
		<EXACT_FIT/>
		<NO_BORDER/>
		<NO_SCALE/>
		<SHOW_ALL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display.TriangleCulling" params="" file="/usr/lib/haxe/std/flash/display/TriangleCulling.hx">
		<NEGATIVE/>
		<NONE/>
		<POSITIVE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.Context3D" params="" file="/usr/lib/haxe/std/flash/display3D/Context3D.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<setVertexBufferAt public="1" set="method"><f a="index:buffer:?bufferOffset:?format">
	<x path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DVertexBufferFormat"/>
	<x path="Void"/>
</f></setVertexBufferAt>
		<setTextureAt public="1" set="method"><f a="sampler:texture">
	<x path="Int"/>
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Void"/>
</f></setTextureAt>
		<setStencilReferenceValue public="1" set="method"><f a="referenceValue:?readMask:?writeMask">
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></setStencilReferenceValue>
		<setStencilActions public="1" set="method"><f a="?triangleFace:?compareMode:?actionOnBothPass:?actionOnDepthFail:?actionOnDepthPassStencilFail">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<e path="flash.display3D.Context3DStencilAction"/>
	<x path="Void"/>
</f></setStencilActions>
		<setScissorRectangle public="1" set="method"><f a="rectangle">
	<c path="flash.geom.Rectangle"/>
	<x path="Void"/>
</f></setScissorRectangle>
		<setRenderToTexture public="1" set="method"><f a="texture:?enableDepthAndStencil:?antiAlias:?surfaceSelector">
	<c path="flash.display3D.textures.TextureBase"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setRenderToTexture>
		<setRenderToBackBuffer public="1" set="method"><f a=""><x path="Void"/></f></setRenderToBackBuffer>
		<setProgramConstantsFromVector public="1" set="method"><f a="programType:firstRegister:data:?numRegisters">
	<e path="flash.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Void"/>
</f></setProgramConstantsFromVector>
		<setProgramConstantsFromMatrix public="1" set="method"><f a="programType:firstRegister:matrix:?transposedMatrix">
	<e path="flash.display3D.Context3DProgramType"/>
	<x path="Int"/>
	<c path="flash.geom.Matrix3D"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setProgramConstantsFromMatrix>
		<setProgram public="1" set="method"><f a="program">
	<c path="flash.display3D.Program3D"/>
	<x path="Void"/>
</f></setProgram>
		<setDepthTest public="1" set="method"><f a="depthMask:passCompareMode">
	<x path="Bool"/>
	<e path="flash.display3D.Context3DCompareMode"/>
	<x path="Void"/>
</f></setDepthTest>
		<setCulling public="1" set="method"><f a="triangleFaceToCull">
	<e path="flash.display3D.Context3DTriangleFace"/>
	<x path="Void"/>
</f></setCulling>
		<setColorMask public="1" set="method"><f a="red:green:blue:alpha">
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setColorMask>
		<setBlendFactors public="1" set="method"><f a="sourceFactor:destinationFactor">
	<e path="flash.display3D.Context3DBlendFactor"/>
	<e path="flash.display3D.Context3DBlendFactor"/>
	<x path="Void"/>
</f></setBlendFactors>
		<present public="1" set="method"><f a=""><x path="Void"/></f></present>
		<drawTriangles public="1" set="method"><f a="indexBuffer:?firstIndex:?numTriangles">
	<c path="flash.display3D.IndexBuffer3D"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></drawTriangles>
		<drawToBitmapData public="1" set="method"><f a="destination">
	<c path="flash.display.BitmapData"/>
	<x path="Void"/>
</f></drawToBitmapData>
		<dispose public="1" set="method"><f a="?recreate">
	<x path="Bool"/>
	<x path="Void"/>
</f></dispose>
		<createVertexBuffer public="1" set="method"><f a="numVertices:data32PerVertex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.display3D.VertexBuffer3D"/>
</f></createVertexBuffer>
		<createTexture public="1" set="method"><f a="width:height:format:optimizeForRenderToTexture:?streamingLevels">
	<x path="Int"/>
	<x path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="flash.display3D.textures.Texture"/>
</f></createTexture>
		<createProgram public="1" set="method"><f a=""><c path="flash.display3D.Program3D"/></f></createProgram>
		<createIndexBuffer public="1" set="method"><f a="numIndices">
	<x path="Int"/>
	<c path="flash.display3D.IndexBuffer3D"/>
</f></createIndexBuffer>
		<createCubeTexture public="1" set="method"><f a="size:format:optimizeForRenderToTexture:?streamingLevels">
	<x path="Int"/>
	<e path="flash.display3D.Context3DTextureFormat"/>
	<x path="Bool"/>
	<x path="Int"/>
	<c path="flash.display3D.textures.CubeTexture"/>
</f></createCubeTexture>
		<configureBackBuffer public="1" set="method"><f a="width:height:antiAlias:?enableDepthAndStencil:?wantsBestResolution">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></configureBackBuffer>
		<clear public="1" set="method"><f a="?red:?green:?blue:?alpha:?depth:?stencil:?mask">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></clear>
		<enableErrorChecking public="1"><x path="Bool"/></enableErrorChecking>
		<driverInfo public="1" set="null"><c path="String"/></driverInfo>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.display3D.Context3DBlendFactor" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DBlendFactor.hx">
		<DESTINATION_ALPHA/>
		<DESTINATION_COLOR/>
		<ONE/>
		<ONE_MINUS_DESTINATION_ALPHA/>
		<ONE_MINUS_DESTINATION_COLOR/>
		<ONE_MINUS_SOURCE_ALPHA/>
		<ONE_MINUS_SOURCE_COLOR/>
		<SOURCE_ALPHA/>
		<SOURCE_COLOR/>
		<ZERO/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DCompareMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DCompareMode.hx">
		<ALWAYS/>
		<EQUAL/>
		<GREATER/>
		<GREATER_EQUAL/>
		<LESS/>
		<LESS_EQUAL/>
		<NEVER/>
		<NOT_EQUAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DMipFilter" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DMipFilter.hx">
		<MIPLINEAR/>
		<MIPNEAREST/>
		<MIPNONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProfile" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProfile.hx">
		<BASELINE/>
		<BASELINE_CONSTRAINED/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DProgramType" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DProgramType.hx">
		<FRAGMENT/>
		<VERTEX/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DStencilAction" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DStencilAction.hx">
		<DECREMENT_SATURATE/>
		<DECREMENT_WRAP/>
		<INCREMENT_SATURATE/>
		<INCREMENT_WRAP/>
		<INVERT/>
		<KEEP/>
		<SET/>
		<ZERO/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFilter" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFilter.hx">
		<LINEAR/>
		<NEAREST/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTextureFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTextureFormat.hx">
		<BGRA/>
		<BGRA_PACKED/>
		<BGR_PACKED/>
		<COMPRESSED/>
		<COMPRESSED_ALPHA/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DTriangleFace" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DTriangleFace.hx">
		<BACK/>
		<FRONT/>
		<FRONT_AND_BACK/>
		<NONE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DVertexBufferFormat" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DVertexBufferFormat.hx">
		<BYTES_4/>
		<FLOAT_1/>
		<FLOAT_2/>
		<FLOAT_3/>
		<FLOAT_4/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.display3D.Context3DWrapMode" params="" file="/usr/lib/haxe/std/flash/display3D/Context3DWrapMode.hx">
		<CLAMP/>
		<REPEAT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.display3D.IndexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/IndexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startOffset:count">
	<c path="flash.Vector"><x path="UInt"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startOffset:count">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.Program3D" params="" file="/usr/lib/haxe/std/flash/display3D/Program3D.hx" extern="1">
		<upload public="1" set="method"><f a="vertexProgram:fragmentProgram">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.utils.ByteArray"/>
	<x path="Void"/>
</f></upload>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.VertexBuffer3D" params="" file="/usr/lib/haxe/std/flash/display3D/VertexBuffer3D.hx" extern="1">
		<uploadFromVector public="1" set="method"><f a="data:startVertex:numVertices">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromVector>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:startVertex:numVertices">
	<c path="flash.utils.ByteArray"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.TextureBase" params="" file="/usr/lib/haxe/std/flash/display3D/textures/TextureBase.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
	</class>
	<class path="flash.display3D.textures.CubeTexture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/CubeTexture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:side:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:side:?miplevel">
	<c path="flash.display.BitmapData"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.display3D.textures.Texture" params="" file="/usr/lib/haxe/std/flash/display3D/textures/Texture.hx" extern="1">
		<extends path="flash.display3D.textures.TextureBase"/>
		<uploadFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?miplevel">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromByteArray>
		<uploadFromBitmapData public="1" set="method"><f a="source:?miplevel">
	<c path="flash.display.BitmapData"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></uploadFromBitmapData>
		<uploadCompressedTextureFromByteArray public="1" set="method"><f a="data:byteArrayOffset:?async">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></uploadCompressedTextureFromByteArray>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.errors.Error" params="" file="/usr/lib/haxe/std/flash/errors/Error.hx" extern="1">
		<length public="1" static="1"><x path="Int"/></length>
		<getErrorMessage public="1" set="method" static="1"><f a="index">
	<x path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" set="method" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<x path="Class"><d/></x>
	<x path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<getStackTrace public="1" set="method"><f a=""><c path="String"/></f></getStackTrace>
		<name public="1"><d/></name>
		<message public="1"><d/></message>
		<errorID public="1" set="null"><x path="Int"/></errorID>
		<new public="1" set="method"><f a="?message:?id">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<ADDED_TO_STAGE public="1" static="1"><c path="String"/></ADDED_TO_STAGE>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CHANNEL_MESSAGE public="1" static="1"><c path="String"/></CHANNEL_MESSAGE>
		<CHANNEL_STATE public="1" static="1"><c path="String"/></CHANNEL_STATE>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<FULLSCREEN public="1" static="1"><c path="String"/></FULLSCREEN>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<REMOVED_FROM_STAGE public="1" static="1"><c path="String"/></REMOVED_FROM_STAGE>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<VIDEO_FRAME public="1" static="1"><c path="String"/></VIDEO_FRAME>
		<WORKER_STATE public="1" static="1"><c path="String"/></WORKER_STATE>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<stopPropagation public="1" set="method"><f a=""><x path="Void"/></f></stopPropagation>
		<stopImmediatePropagation public="1" set="method"><f a=""><x path="Void"/></f></stopImmediatePropagation>
		<preventDefault public="1" set="method"><f a=""><x path="Void"/></f></preventDefault>
		<isDefaultPrevented public="1" set="method"><f a=""><x path="Bool"/></f></isDefaultPrevented>
		<formatToString public="1" set="method"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<clone public="1" set="method"><f a=""><c path="flash.events.Event"/></f></clone>
		<type public="1" set="null"><c path="String"/></type>
		<target public="1" set="null"><d/></target>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<cancelable public="1" set="null"><x path="Bool"/></cancelable>
		<bubbles public="1" set="null"><x path="Bool"/></bubbles>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.TextEvent" params="" file="/usr/lib/haxe/std/flash/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.ErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/ErrorEvent.hx" extern="1">
		<extends path="flash.events.TextEvent"/>
		<ERROR public="1" static="1"><c path="String"/></ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash/events/EventPhase.hx">
		<AT_TARGET/>
		<BUBBLING_PHASE/>
		<CAPTURING_PHASE/>
		<meta><m n=":fakeEnum"><e>UInt</e></m></meta>
	</enum>
	<class path="flash.events.HTTPStatusEvent" params="" file="/usr/lib/haxe/std/flash/events/HTTPStatusEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<HTTP_STATUS public="1" static="1"><c path="String"/></HTTP_STATUS>
		<status public="1" set="null"><x path="Int"/></status>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?status">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.IOErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/IOErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<DISK_ERROR public="1" static="1"><c path="String"/></DISK_ERROR>
		<IO_ERROR public="1" static="1"><c path="String"/></IO_ERROR>
		<NETWORK_ERROR public="1" static="1"><c path="String"/></NETWORK_ERROR>
		<VERIFY_ERROR public="1" static="1"><c path="String"/></VERIFY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.SecurityErrorEvent" params="" file="/usr/lib/haxe/std/flash/events/SecurityErrorEvent.hx" extern="1">
		<extends path="flash.events.ErrorEvent"/>
		<SECURITY_ERROR public="1" static="1"><c path="String"/></SECURITY_ERROR>
		<new public="1" set="method"><f a="type:?bubbles:?cancelable:?text:?id">
	<c path="String"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.events.UncaughtErrorEvents" params="" file="/usr/lib/haxe/std/flash/events/UncaughtErrorEvents.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_1</e></m></meta>
	</class>
	<class path="flash.external.ExternalInterface" params="" file="/usr/lib/haxe/std/flash/external/ExternalInterface.hx" extern="1">
		<available public="1" set="null" static="1"><x path="Bool"/></available>
		<marshallExceptions public="1" static="1"><x path="Bool"/></marshallExceptions>
		<objectID public="1" set="null" static="1"><c path="String"/></objectID>
		<addCallback public="1" set="method" static="1"><f a="functionName:closure">
	<c path="String"/>
	<d/>
	<x path="Void"/>
</f></addCallback>
		<call public="1" set="method" static="1"><f a="functionName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></call>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash/filters/BitmapFilter.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash/geom/ColorTransform.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<concat public="1" set="method"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<x path="Void"/>
</f></concat>
		<redOffset public="1"><x path="Float"/></redOffset>
		<redMultiplier public="1"><x path="Float"/></redMultiplier>
		<greenOffset public="1"><x path="Float"/></greenOffset>
		<greenMultiplier public="1"><x path="Float"/></greenMultiplier>
		<color public="1"><x path="UInt"/></color>
		<blueOffset public="1"><x path="Float"/></blueOffset>
		<blueMultiplier public="1"><x path="Float"/></blueMultiplier>
		<alphaOffset public="1"><x path="Float"/></alphaOffset>
		<alphaMultiplier public="1"><x path="Float"/></alphaMultiplier>
		<new public="1" set="method"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash/geom/Matrix.hx" extern="1">
		<translate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></translate>
		<transformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<scale public="1" set="method"><f a="sx:sy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></scale>
		<rotate public="1" set="method"><f a="angle">
	<x path="Float"/>
	<x path="Void"/>
</f></rotate>
		<invert public="1" set="method"><f a=""><x path="Void"/></f></invert>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<deltaTransformPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<createGradientBox public="1" set="method"><f a="width:height:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createGradientBox>
		<createBox public="1" set="method"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></createBox>
		<concat public="1" set="method"><f a="m">
	<c path="flash.geom.Matrix"/>
	<x path="Void"/>
</f></concat>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<ty public="1"><x path="Float"/></ty>
		<tx public="1"><x path="Float"/></tx>
		<d public="1"><x path="Float"/></d>
		<c public="1"><x path="Float"/></c>
		<b public="1"><x path="Float"/></b>
		<a public="1"><x path="Float"/></a>
		<new public="1" set="method"><f a="?a:?b:?c:?d:?tx:?ty">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Matrix3D" params="" file="/usr/lib/haxe/std/flash/geom/Matrix3D.hx" extern="1">
		<transpose public="1" set="method"><f a=""><x path="Void"/></f></transpose>
		<transformVectors public="1" set="method"><f a="vin:vout">
	<c path="flash.Vector"><x path="Float"/></c>
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></transformVectors>
		<transformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></transformVector>
		<recompose public="1" set="method"><f a="components:?orientationStyle">
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
	<e path="flash.geom.Orientation3D"/>
	<x path="Bool"/>
</f></recompose>
		<prependTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependTranslation>
		<prependScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></prependScale>
		<prependRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></prependRotation>
		<prepend public="1" set="method"><f a="rhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></prepend>
		<pointAt public="1" set="method"><f a="pos:?at:?up">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></pointAt>
		<invert public="1" set="method"><f a=""><x path="Bool"/></f></invert>
		<interpolateTo public="1" set="method"><f a="toMat:percent">
	<c path="flash.geom.Matrix3D"/>
	<x path="Float"/>
	<x path="Void"/>
</f></interpolateTo>
		<identity public="1" set="method"><f a=""><x path="Void"/></f></identity>
		<deltaTransformVector public="1" set="method"><f a="v">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></deltaTransformVector>
		<decompose public="1" set="method"><f a="?orientationStyle">
	<e path="flash.geom.Orientation3D"/>
	<c path="flash.Vector"><c path="flash.geom.Vector3D"/></c>
</f></decompose>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></clone>
		<appendTranslation public="1" set="method"><f a="x:y:z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendTranslation>
		<appendScale public="1" set="method"><f a="xScale:yScale:zScale">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></appendScale>
		<appendRotation public="1" set="method"><f a="degrees:axis:?pivotPoint">
	<x path="Float"/>
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></appendRotation>
		<append public="1" set="method"><f a="lhs">
	<c path="flash.geom.Matrix3D"/>
	<x path="Void"/>
</f></append>
		<rawData public="1"><c path="flash.Vector"><x path="Float"/></c></rawData>
		<position public="1"><c path="flash.geom.Vector3D"/></position>
		<determinant public="1" set="null"><x path="Float"/></determinant>
		<new public="1"><f a="?v">
	<c path="flash.Vector"><x path="Float"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<enum path="flash.geom.Orientation3D" params="" file="/usr/lib/haxe/std/flash/geom/Orientation3D.hx">
		<AXIS_ANGLE/>
		<EULER_ANGLES/>
		<QUATERNION/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.geom.PerspectiveProjection" params="" file="/usr/lib/haxe/std/flash/geom/PerspectiveProjection.hx" extern="1">
		<toMatrix3D public="1" set="method"><f a=""><c path="flash.geom.Matrix3D"/></f></toMatrix3D>
		<projectionCenter public="1"><c path="flash.geom.Point"/></projectionCenter>
		<focalLength public="1"><x path="Float"/></focalLength>
		<fieldOfView public="1"><x path="Float"/></fieldOfView>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash/geom/Point.hx" extern="1">
		<distance public="1" set="method" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
</f></distance>
		<interpolate public="1" set="method" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" set="method" static="1"><f a="len:angle">
	<x path="Float"/>
	<x path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<normalize public="1" set="method"><f a="thickness">
	<x path="Float"/>
	<x path="Void"/>
</f></normalize>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></equals>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Point"/></f></clone>
		<add public="1" set="method"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<length public="1" set="null"><x path="Float"/></length>
		<new public="1" set="method"><f a="?x:?y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash/geom/Rectangle.hx" extern="1">
		<union public="1" set="method"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<setEmpty public="1" set="method"><f a=""><x path="Void"/></f></setEmpty>
		<offsetPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></offsetPoint>
		<offset public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></offset>
		<isEmpty public="1" set="method"><f a=""><x path="Bool"/></f></isEmpty>
		<intersects public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></intersects>
		<intersection public="1" set="method"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<inflatePoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Void"/>
</f></inflatePoint>
		<inflate public="1" set="method"><f a="dx:dy">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></inflate>
		<equals public="1" set="method"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></equals>
		<containsRect public="1" set="method"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<x path="Bool"/>
</f></containsRect>
		<containsPoint public="1" set="method"><f a="point">
	<c path="flash.geom.Point"/>
	<x path="Bool"/>
</f></containsPoint>
		<contains public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Bool"/>
</f></contains>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<top public="1"><x path="Float"/></top>
		<size public="1"><c path="flash.geom.Point"/></size>
		<right public="1"><x path="Float"/></right>
		<left public="1"><x path="Float"/></left>
		<height public="1"><x path="Float"/></height>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<bottom public="1"><x path="Float"/></bottom>
		<new public="1" set="method"><f a="?x:?y:?width:?height">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash/geom/Transform.hx" extern="1">
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<new public="1" set="method"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Vector3D" params="" file="/usr/lib/haxe/std/flash/geom/Vector3D.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<subtract public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></subtract>
		<scaleBy public="1" set="method"><f a="s">
	<x path="Float"/>
	<x path="Void"/>
</f></scaleBy>
		<project public="1" set="method"><f a=""><x path="Void"/></f></project>
		<normalize public="1" set="method"><f a=""><x path="Float"/></f></normalize>
		<negate public="1" set="method"><f a=""><x path="Void"/></f></negate>
		<nearEquals public="1" set="method"><f a="toCompare:tolerance:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></nearEquals>
		<incrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></incrementBy>
		<equals public="1" set="method"><f a="toCompare:?allFour">
	<c path="flash.geom.Vector3D"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></equals>
		<dotProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Float"/>
</f></dotProduct>
		<decrementBy public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<x path="Void"/>
</f></decrementBy>
		<crossProduct public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></crossProduct>
		<clone public="1" set="method"><f a=""><c path="flash.geom.Vector3D"/></f></clone>
		<add public="1" set="method"><f a="a">
	<c path="flash.geom.Vector3D"/>
	<c path="flash.geom.Vector3D"/>
</f></add>
		<z public="1"><x path="Float"/></z>
		<y public="1"><x path="Float"/></y>
		<x public="1"><x path="Float"/></x>
		<w public="1"><x path="Float"/></w>
		<lengthSquared public="1" set="null"><x path="Float"/></lengthSquared>
		<length public="1" set="null"><x path="Float"/></length>
		<new public="1"><f a="?x:?y:?z:?w">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":require"><e>flash10</e></m></meta>
	</class>
	<class path="flash.media.AVCaptionStyle" params="" file="/usr/lib/haxe/std/flash/media/AVCaptionStyle.hx" extern="1">
		<BLACK public="1" static="1"><c path="String"/></BLACK>
		<BLUE public="1" static="1"><c path="String"/></BLUE>
		<BRIGHT_BLUE public="1" static="1"><c path="String"/></BRIGHT_BLUE>
		<BRIGHT_CYAN public="1" static="1"><c path="String"/></BRIGHT_CYAN>
		<BRIGHT_GREEN public="1" static="1"><c path="String"/></BRIGHT_GREEN>
		<BRIGHT_MAGENTA public="1" static="1"><c path="String"/></BRIGHT_MAGENTA>
		<BRIGHT_RED public="1" static="1"><c path="String"/></BRIGHT_RED>
		<BRIGHT_WHITE public="1" static="1"><c path="String"/></BRIGHT_WHITE>
		<BRIGHT_YELLOW public="1" static="1"><c path="String"/></BRIGHT_YELLOW>
		<CASUAL public="1" static="1"><c path="String"/></CASUAL>
		<CURSIVE public="1" static="1"><c path="String"/></CURSIVE>
		<CYAN public="1" static="1"><c path="String"/></CYAN>
		<DARK_BLUE public="1" static="1"><c path="String"/></DARK_BLUE>
		<DARK_CYAN public="1" static="1"><c path="String"/></DARK_CYAN>
		<DARK_GREEN public="1" static="1"><c path="String"/></DARK_GREEN>
		<DARK_MAGENTA public="1" static="1"><c path="String"/></DARK_MAGENTA>
		<DARK_RED public="1" static="1"><c path="String"/></DARK_RED>
		<DARK_YELLOW public="1" static="1"><c path="String"/></DARK_YELLOW>
		<DEFAULT public="1" static="1"><c path="String"/></DEFAULT>
		<DEPRESSED public="1" static="1"><c path="String"/></DEPRESSED>
		<GRAY public="1" static="1"><c path="String"/></GRAY>
		<GREEN public="1" static="1"><c path="String"/></GREEN>
		<LARGE public="1" static="1"><c path="String"/></LARGE>
		<LEFT_DROP_SHADOW public="1" static="1"><c path="String"/></LEFT_DROP_SHADOW>
		<MAGENTA public="1" static="1"><c path="String"/></MAGENTA>
		<MEDIUM public="1" static="1"><c path="String"/></MEDIUM>
		<MONOSPACED_WITHOUT_SERIFS public="1" static="1"><c path="String"/></MONOSPACED_WITHOUT_SERIFS>
		<MONOSPACE_WITH_SERIFS public="1" static="1"><c path="String"/></MONOSPACE_WITH_SERIFS>
		<NONE public="1" static="1"><c path="String"/></NONE>
		<PROPORTIONAL_WITHOUT_SERIFS public="1" static="1"><c path="String"/></PROPORTIONAL_WITHOUT_SERIFS>
		<PROPORTIONAL_WITH_SERIFS public="1" static="1"><c path="String"/></PROPORTIONAL_WITH_SERIFS>
		<RAISED public="1" static="1"><c path="String"/></RAISED>
		<RED public="1" static="1"><c path="String"/></RED>
		<RIGHT_DROP_SHADOW public="1" static="1"><c path="String"/></RIGHT_DROP_SHADOW>
		<SMALL public="1" static="1"><c path="String"/></SMALL>
		<SMALL_CAPITALS public="1" static="1"><c path="String"/></SMALL_CAPITALS>
		<UNIFORM public="1" static="1"><c path="String"/></UNIFORM>
		<WHITE public="1" static="1"><c path="String"/></WHITE>
		<YELLOW public="1" static="1"><c path="String"/></YELLOW>
		<size public="1"><c path="String"/></size>
		<fontOpacity public="1"><c path="String"/></fontOpacity>
		<fontEdge public="1"><c path="String"/></fontEdge>
		<fontColor public="1"><c path="String"/></fontColor>
		<font public="1"><c path="String"/></font>
		<fillOpacity public="1"><c path="String"/></fillOpacity>
		<fillColor public="1"><c path="String"/></fillColor>
		<edgeColor public="1"><c path="String"/></edgeColor>
		<backgroundOpacity public="1"><c path="String"/></backgroundOpacity>
		<backgroundColor public="1"><c path="String"/></backgroundColor>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVPlayState" params="" file="/usr/lib/haxe/std/flash/media/AVPlayState.hx" extern="1">
		<BUFFERING public="1" static="1"><x path="Int"/></BUFFERING>
		<EOF public="1" static="1"><x path="Int"/></EOF>
		<PAUSED public="1" static="1"><x path="Int"/></PAUSED>
		<PLAYING public="1" static="1"><x path="Int"/></PLAYING>
		<READY public="1" static="1"><x path="Int"/></READY>
		<SUSPENDED public="1" static="1"><x path="Int"/></SUSPENDED>
		<UNINITIALIZED public="1" static="1"><x path="Int"/></UNINITIALIZED>
		<UNRECOVERABLE_ERROR public="1" static="1"><x path="Int"/></UNRECOVERABLE_ERROR>
		<state public="1" set="null"><x path="Int"/></state>
		<new public="1" set="method"><f a="state">
	<x path="UInt"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVResult" params="" file="/usr/lib/haxe/std/flash/media/AVResult.hx" extern="1">
		<ASYNC_OPERATION_IN_PROGRESS public="1" static="1"><x path="Int"/></ASYNC_OPERATION_IN_PROGRESS>
		<BAD_MANIFEST_SIGNATURE public="1" static="1"><x path="Int"/></BAD_MANIFEST_SIGNATURE>
		<BAD_MEDIA_INTERLEAVING public="1" static="1"><x path="Int"/></BAD_MEDIA_INTERLEAVING>
		<CALLED_FROM_WRONG_THREAD public="1" static="1"><x path="Int"/></CALLED_FROM_WRONG_THREAD>
		<CANNOT_FAIL_OVER public="1" static="1"><x path="Int"/></CANNOT_FAIL_OVER>
		<CANNOT_LOAD_PLAY_LIST public="1" static="1"><x path="Int"/></CANNOT_LOAD_PLAY_LIST>
		<CODEC_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CODEC_NOT_SUPPORTED>
		<COMPONENT_CREATION_FAILURE public="1" static="1"><x path="Int"/></COMPONENT_CREATION_FAILURE>
		<CONTAINER_NOT_SUPPORTED public="1" static="1"><x path="Int"/></CONTAINER_NOT_SUPPORTED>
		<CONTENT_LENGTH_MISMATCH public="1" static="1"><x path="Int"/></CONTENT_LENGTH_MISMATCH>
		<CURRENT_PERIOD_EXPIRED public="1" static="1"><x path="Int"/></CURRENT_PERIOD_EXPIRED>
		<DECODER_FAILED public="1" static="1"><x path="Int"/></DECODER_FAILED>
		<DEVICE_OPEN_ERROR public="1" static="1"><x path="Int"/></DEVICE_OPEN_ERROR>
		<DRM_INIT_ERROR public="1" static="1"><x path="Int"/></DRM_INIT_ERROR>
		<DRM_NOT_AVAILABLE public="1" static="1"><x path="Int"/></DRM_NOT_AVAILABLE>
		<EOF public="1" static="1"><x path="Int"/></EOF>
		<FILE_NOT_FOUND public="1" static="1"><x path="Int"/></FILE_NOT_FOUND>
		<FILE_STRUCTURE_INVALID public="1" static="1"><x path="Int"/></FILE_STRUCTURE_INVALID>
		<FRAGMENT_READ_ERROR public="1" static="1"><x path="Int"/></FRAGMENT_READ_ERROR>
		<GENERIC_ERROR public="1" static="1"><x path="Int"/></GENERIC_ERROR>
		<HTTP_TIME_OUT public="1" static="1"><x path="Int"/></HTTP_TIME_OUT>
		<INVALID_OPERATION public="1" static="1"><x path="Int"/></INVALID_OPERATION>
		<INVALID_PARAMETER public="1" static="1"><x path="Int"/></INVALID_PARAMETER>
		<INVALID_REPLACE_DURATION public="1" static="1"><x path="Int"/></INVALID_REPLACE_DURATION>
		<INVALID_SEEK_TIME public="1" static="1"><x path="Int"/></INVALID_SEEK_TIME>
		<INVALID_WITH_AUDIO_ONLY_FILE public="1" static="1"><x path="Int"/></INVALID_WITH_AUDIO_ONLY_FILE>
		<IRRECOVERABLE_ERROR public="1" static="1"><x path="Int"/></IRRECOVERABLE_ERROR>
		<LIVE_HOLD public="1" static="1"><x path="Int"/></LIVE_HOLD>
		<LIVE_WINDOW_MOVED_BACKWARD public="1" static="1"><x path="Int"/></LIVE_WINDOW_MOVED_BACKWARD>
		<LOST_CONNECTION_RECOVERABLE public="1" static="1"><x path="Int"/></LOST_CONNECTION_RECOVERABLE>
		<NETWORK_DOWN public="1" static="1"><x path="Int"/></NETWORK_DOWN>
		<NETWORK_ERROR public="1" static="1"><x path="Int"/></NETWORK_ERROR>
		<NETWORK_UNAVAILABLE public="1" static="1"><x path="Int"/></NETWORK_UNAVAILABLE>
		<NOT_IMPLEMENTED public="1" static="1"><x path="Int"/></NOT_IMPLEMENTED>
		<NO_FIXED_SIZE public="1" static="1"><x path="Int"/></NO_FIXED_SIZE>
		<NO_USEABLE_BITRATE_PROFILE public="1" static="1"><x path="Int"/></NO_USEABLE_BITRATE_PROFILE>
		<ONLY_ALLOWED_IN_PAUSED_STATE public="1" static="1"><x path="Int"/></ONLY_ALLOWED_IN_PAUSED_STATE>
		<OPERATION_ABORTED public="1" static="1"><x path="Int"/></OPERATION_ABORTED>
		<OUT_OF_MEMORY public="1" static="1"><x path="Int"/></OUT_OF_MEMORY>
		<OVERFLOW public="1" static="1"><x path="Int"/></OVERFLOW>
		<PARSE_ERROR public="1" static="1"><x path="Int"/></PARSE_ERROR>
		<PERIOD_HOLD public="1" static="1"><x path="Int"/></PERIOD_HOLD>
		<PERIOD_NOT_LOADED public="1" static="1"><x path="Int"/></PERIOD_NOT_LOADED>
		<PLAYBACK_NOT_ENABLED public="1" static="1"><x path="Int"/></PLAYBACK_NOT_ENABLED>
		<PREVIOUS_STEP_SEEK_IN_PROGRESS public="1" static="1"><x path="Int"/></PREVIOUS_STEP_SEEK_IN_PROGRESS>
		<RANGE_ERROR public="1" static="1"><x path="Int"/></RANGE_ERROR>
		<REPLACEMENT_FAILED public="1" static="1"><x path="Int"/></REPLACEMENT_FAILED>
		<RESOURCE_NOT_SPECIFIED public="1" static="1"><x path="Int"/></RESOURCE_NOT_SPECIFIED>
		<SEEK_FAILED public="1" static="1"><x path="Int"/></SEEK_FAILED>
		<SIZE_UNKNOWN public="1" static="1"><x path="Int"/></SIZE_UNKNOWN>
		<SUCCESS public="1" static="1"><x path="Int"/></SUCCESS>
		<SWITCH_TO_ASYMMETRIC_PROFILE public="1" static="1"><x path="Int"/></SWITCH_TO_ASYMMETRIC_PROFILE>
		<UNDERFLOW public="1" static="1"><x path="Int"/></UNDERFLOW>
		<UNSUPPORTED_CONFIGURATION public="1" static="1"><x path="Int"/></UNSUPPORTED_CONFIGURATION>
		<UNSUPPORTED_HLS_VERSION public="1" static="1"><x path="Int"/></UNSUPPORTED_HLS_VERSION>
		<UNSUPPORTED_OPERATION public="1" static="1"><x path="Int"/></UNSUPPORTED_OPERATION>
		<VIDEO_PROFILE_NOT_SUPPORTED public="1" static="1"><x path="Int"/></VIDEO_PROFILE_NOT_SUPPORTED>
		<WAITING_FOR_INIT public="1" static="1"><x path="Int"/></WAITING_FOR_INIT>
		<result public="1" set="null"><x path="Int"/></result>
		<new public="1" set="method"><f a="inResult">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.AVSource" params="" file="/usr/lib/haxe/std/flash/media/AVSource.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.media.AVStream" params="" file="/usr/lib/haxe/std/flash/media/AVStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<HARDWARE public="1" static="1"><c path="String"/></HARDWARE>
		<SOFTWARE public="1" static="1"><c path="String"/></SOFTWARE>
		<UNDEFINED public="1" static="1"><c path="String"/></UNDEFINED>
		<step public="1" set="method"><f a="frames">
	<x path="Int"/>
	<c path="flash.media.AVResult"/>
</f></step>
		<seekToLocalTime public="1" set="method"><f a="periodIndex:time">
	<x path="Int"/>
	<x path="Float"/>
	<c path="flash.media.AVResult"/>
</f></seekToLocalTime>
		<seekToLivePoint public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></seekToLivePoint>
		<seek public="1" set="method"><f a="offset:?inBufferSeek">
	<x path="Float"/>
	<x path="Bool"/>
	<c path="flash.media.AVResult"/>
</f></seek>
		<resume public="1" set="method"><f a=""><x path="Bool"/></f></resume>
		<play public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></play>
		<pause public="1" set="method"><f a=""><c path="flash.media.AVResult"/></f></pause>
		<dispose public="1" set="method"><f a=""><x path="Void"/></f></dispose>
		<volume public="1"><x path="Float"/></volume>
		<useHardwareDecoder public="1"><x path="Bool"/></useHardwareDecoder>
		<time public="1" set="null"><x path="Float"/></time>
		<renderType public="1" set="null"><c path="String"/></renderType>
		<playState public="1" set="null"><c path="flash.media.AVPlayState"/></playState>
		<initialBufferTime public="1" get="null"><x path="Float"/></initialBufferTime>
		<frameTime public="1" set="null"><x path="Float"/></frameTime>
		<droppedFrames public="1" set="null"><x path="Int"/></droppedFrames>
		<decoderType public="1" set="null"><c path="String"/></decoderType>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<captionsEnabled public="1"><x path="Bool"/></captionsEnabled>
		<captionStyle public="1" get="null"><c path="flash.media.AVCaptionStyle"/></captionStyle>
		<bufferTime public="1" get="null"><x path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<backBufferTime public="1" get="null"><x path="Float"/></backBufferTime>
		<backBufferLength public="1" set="null"><x path="Float"/></backBufferLength>
		<new public="1" set="method"><f a="source">
	<c path="flash.media.AVSource"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.media.Camera" params="" file="/usr/lib/haxe/std/flash/media/Camera.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getCamera public="1" set="method" static="1"><f a="?name">
	<c path="String"/>
	<c path="flash.media.Camera"/>
</f></getCamera>
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<setMotionLevel public="1" set="method"><f a="motionLevel:?timeout">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setMotionLevel>
		<setMode public="1" set="method"><f a="width:height:fps:?favorArea">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setMode>
		<setLoopback public="1" set="method"><f a="?compress">
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoopback>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<setCursor public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setCursor>
		<width public="1" set="null"><x path="Int"/></width>
		<quality public="1" set="null"><x path="Int"/></quality>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<motionTimeout public="1" set="null"><x path="Int"/></motionTimeout>
		<motionLevel public="1" set="null"><x path="Int"/></motionLevel>
		<loopback public="1" set="null"><x path="Bool"/></loopback>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<index public="1" set="null"><x path="Int"/></index>
		<height public="1" set="null"><x path="Int"/></height>
		<fps public="1" set="null"><x path="Float"/></fps>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.Microphone" params="" file="/usr/lib/haxe/std/flash/media/Microphone.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<names public="1" set="null" static="1"><c path="Array"><d/></c></names>
		<getMicrophone public="1" set="method" static="1"><f a="?index">
	<x path="Int"/>
	<c path="flash.media.Microphone"/>
</f></getMicrophone>
		<setUseEchoSuppression public="1" set="method"><f a="useEchoSuppression">
	<x path="Bool"/>
	<x path="Void"/>
</f></setUseEchoSuppression>
		<setSilenceLevel public="1" set="method"><f a="silenceLevel:?timeout">
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSilenceLevel>
		<setLoopBack public="1" set="method"><f a="?state">
	<x path="Bool"/>
	<x path="Void"/>
</f></setLoopBack>
		<useEchoSuppression public="1" set="null"><x path="Bool"/></useEchoSuppression>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<silenceTimeout public="1" set="null"><x path="Int"/></silenceTimeout>
		<silenceLevel public="1" set="null"><x path="Float"/></silenceLevel>
		<rate public="1"><x path="Int"/></rate>
		<name public="1" set="null"><c path="String"/></name>
		<muted public="1" set="null"><x path="Bool"/></muted>
		<index public="1" set="null"><x path="Int"/></index>
		<gain public="1"><x path="Float"/></gain>
		<activityLevel public="1" set="null"><x path="Float"/></activityLevel>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="flash.media.MicrophoneEnhancedMode" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedMode.hx">
		<FULL_DUPLEX/>
		<HALF_DUPLEX/>
		<HEADSET/>
		<OFF/>
		<SPEAKER_MUTE/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</enum>
	<class path="flash.media.MicrophoneEnhancedOptions" params="" file="/usr/lib/haxe/std/flash/media/MicrophoneEnhancedOptions.hx" extern="1">
		<nonLinearProcessing public="1"><x path="Bool"/></nonLinearProcessing>
		<mode public="1"><e path="flash.media.MicrophoneEnhancedMode"/></mode>
		<isVoiceDetected public="1"><x path="Int"/></isVoiceDetected>
		<echoPath public="1"><x path="Int"/></echoPath>
		<autoGain public="1"><x path="Bool"/></autoGain>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_2</e></m>
		</meta>
	</class>
	<enum path="flash.media.SoundCodec" params="" file="/usr/lib/haxe/std/flash/media/SoundCodec.hx">
		<NELLYMOSER/>
		<PCMA/>
		<PCMU/>
		<SPEEX/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash/media/SoundTransform.hx" extern="1">
		<volume public="1"><x path="Float"/></volume>
		<rightToRight public="1"><x path="Float"/></rightToRight>
		<rightToLeft public="1"><x path="Float"/></rightToLeft>
		<pan public="1"><x path="Float"/></pan>
		<leftToRight public="1"><x path="Float"/></leftToRight>
		<leftToLeft public="1"><x path="Float"/></leftToLeft>
		<new public="1" set="method"><f a="?vol:?panning">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.media.StageVideo" params="" file="/usr/lib/haxe/std/flash/media/StageVideo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<attachNetStream public="1" set="method"><f a="netStream">
	<c path="flash.net.NetStream"/>
	<x path="Void"/>
</f></attachNetStream>
		<zoom public="1"><c path="flash.geom.Point"/></zoom>
		<viewPort public="1"><c path="flash.geom.Rectangle"/></viewPort>
		<videoWidth public="1" set="null"><x path="Int"/></videoWidth>
		<videoHeight public="1" set="null"><x path="Int"/></videoHeight>
		<pan public="1"><c path="flash.geom.Point"/></pan>
		<depth public="1"><x path="Int"/></depth>
		<colorSpaces public="1" set="null"><c path="flash.Vector"><c path="String"/></c></colorSpaces>
		<new public="1"><f a=""><x path="Void"/></f></new>
		<meta><m n=":require"><e>flash10_2</e></m></meta>
	</class>
	<class path="flash.media.VideoStreamSettings" params="" file="/usr/lib/haxe/std/flash/media/VideoStreamSettings.hx" extern="1">
		<setQuality public="1" set="method"><f a="bandwidth:quality">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setQuality>
		<setMode public="1" set="method"><f a="width:height:fps">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setMode>
		<setKeyFrameInterval public="1" set="method"><f a="keyFrameInterval">
	<x path="Int"/>
	<x path="Void"/>
</f></setKeyFrameInterval>
		<width public="1" set="null"><x path="Int"/></width>
		<quality public="1" set="null"><x path="Int"/></quality>
		<keyFrameInterval public="1" set="null"><x path="Int"/></keyFrameInterval>
		<height public="1" set="null"><x path="Int"/></height>
		<fps public="1" set="null"><x path="Float"/></fps>
		<codec public="1" set="null"><c path="String"/></codec>
		<bandwidth public="1" set="null"><x path="Int"/></bandwidth>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetConnection" params="" file="/usr/lib/haxe/std/flash/net/NetConnection.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<connect public="1" set="method"><f a="command:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></connect>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<call public="1" set="method"><f a="command:responder:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<c path="flash.net.Responder"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></call>
		<addHeader public="1" set="method"><f a="operation:?mustUnderstand:?param">
	<c path="String"/>
	<x path="Bool"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></addHeader>
		<usingTLS public="1" set="null"><x path="Bool"/></usingTLS>
		<uri public="1" set="null"><c path="String"/></uri>
		<proxyType public="1"><c path="String"/></proxyType>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<connectedProxyType public="1" set="null"><c path="String"/></connectedProxyType>
		<connected public="1" set="null"><x path="Bool"/></connected>
		<client public="1"><d/></client>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.net.NetStream" params="" file="/usr/lib/haxe/std/flash/net/NetStream.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<togglePause public="1" set="method"><f a=""><x path="Void"/></f></togglePause>
		<send public="1" set="method"><f a="handlerName:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></send>
		<seek public="1" set="method"><f a="offset">
	<x path="Float"/>
	<x path="Void"/>
</f></seek>
		<resume public="1" set="method"><f a=""><x path="Void"/></f></resume>
		<receiveVideoFPS public="1" set="method"><f a="FPS">
	<x path="Float"/>
	<x path="Void"/>
</f></receiveVideoFPS>
		<receiveVideo public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveVideo>
		<receiveAudio public="1" set="method"><f a="flag">
	<x path="Bool"/>
	<x path="Void"/>
</f></receiveAudio>
		<publish public="1" set="method"><f a="?name:?type">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></publish>
		<play public="1" set="method"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<x path="Void"/>
</f></play>
		<pause public="1" set="method"><f a=""><x path="Void"/></f></pause>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<attachCamera public="1" set="method"><f a="theCamera:?snapshotMilliseconds">
	<c path="flash.media.Camera"/>
	<x path="Int"/>
	<x path="Void"/>
</f></attachCamera>
		<attachAudio public="1" set="method"><f a="microphone">
	<c path="flash.media.Microphone"/>
	<x path="Void"/>
</f></attachAudio>
		<videoCodec public="1" set="null"><x path="UInt"/></videoCodec>
		<time public="1" set="null"><x path="Float"/></time>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<objectEncoding public="1" set="null"><x path="UInt"/></objectEncoding>
		<liveDelay public="1" set="null"><x path="Float"/></liveDelay>
		<decodedFrames public="1" set="null"><x path="UInt"/></decodedFrames>
		<currentFPS public="1" set="null"><x path="Float"/></currentFPS>
		<client public="1"><d/></client>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<bytesTotal public="1" set="null"><x path="UInt"/></bytesTotal>
		<bytesLoaded public="1" set="null"><x path="UInt"/></bytesLoaded>
		<bufferTime public="1"><x path="Float"/></bufferTime>
		<bufferLength public="1" set="null"><x path="Float"/></bufferLength>
		<audioCodec public="1" set="null"><x path="UInt"/></audioCodec>
		<new public="1" set="method"><f a="connection:?peerID">
	<c path="flash.net.NetConnection"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.net.NetStreamInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<xmpData public="1" set="null"><d/></xmpData>
		<videoBytesPerSecond public="1" set="null"><x path="Float"/></videoBytesPerSecond>
		<videoByteCount public="1" set="null"><x path="Float"/></videoByteCount>
		<videoBufferLength public="1" set="null"><x path="Float"/></videoBufferLength>
		<videoBufferByteLength public="1" set="null"><x path="Float"/></videoBufferByteLength>
		<uri public="1" set="null"><c path="String"/></uri>
		<resourceName public="1" set="null"><c path="String"/></resourceName>
		<playbackBytesPerSecond public="1" set="null"><x path="Float"/></playbackBytesPerSecond>
		<metaData public="1" set="null"><d/></metaData>
		<maxBytesPerSecond public="1" set="null"><x path="Float"/></maxBytesPerSecond>
		<isLive public="1" set="null"><x path="Bool"/></isLive>
		<droppedFrames public="1" set="null"><x path="Float"/></droppedFrames>
		<dataBytesPerSecond public="1" set="null"><x path="Float"/></dataBytesPerSecond>
		<dataByteCount public="1" set="null"><x path="Float"/></dataByteCount>
		<dataBufferLength public="1" set="null"><x path="Float"/></dataBufferLength>
		<dataBufferByteLength public="1" set="null"><x path="Float"/></dataBufferByteLength>
		<currentBytesPerSecond public="1" set="null"><x path="Float"/></currentBytesPerSecond>
		<byteCount public="1" set="null"><x path="Float"/></byteCount>
		<audioLossRate public="1" set="null"><x path="Float"/></audioLossRate>
		<audioBytesPerSecond public="1" set="null"><x path="Float"/></audioBytesPerSecond>
		<audioByteCount public="1" set="null"><x path="Float"/></audioByteCount>
		<audioBufferLength public="1" set="null"><x path="Float"/></audioBufferLength>
		<audioBufferByteLength public="1" set="null"><x path="Float"/></audioBufferByteLength>
		<SRTT public="1" set="null"><x path="Float"/></SRTT>
		<new public="1" set="method"><f a="curBPS:byteCount:maxBPS:audioBPS:audioByteCount:videoBPS:videoByteCount:dataBPS:dataByteCount:playbackBPS:droppedFrames:audioBufferByteLength:videoBufferByteLength:dataBufferByteLength:audioBufferLength:videoBufferLength:dataBufferLength:srtt:audioLossRate:videoLossRate:?metaData:?xmpData:?uri:?resourceName:?isLive">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.NetStreamMulticastInfo" params="" file="/usr/lib/haxe/std/flash/net/NetStreamMulticastInfo.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<sendDataBytesPerSecond public="1" set="null"><x path="Float"/></sendDataBytesPerSecond>
		<sendControlBytesPerSecondToServer public="1" set="null"><x path="Float"/></sendControlBytesPerSecondToServer>
		<sendControlBytesPerSecond public="1" set="null"><x path="Float"/></sendControlBytesPerSecond>
		<receiveDataBytesPerSecondFromServer public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromServer>
		<receiveDataBytesPerSecondFromIPMulticast public="1" set="null"><x path="Float"/></receiveDataBytesPerSecondFromIPMulticast>
		<receiveDataBytesPerSecond public="1" set="null"><x path="Float"/></receiveDataBytesPerSecond>
		<receiveControlBytesPerSecond public="1" set="null"><x path="Float"/></receiveControlBytesPerSecond>
		<fragmentsRequestedFromPeers public="1" set="null"><x path="Float"/></fragmentsRequestedFromPeers>
		<fragmentsRequestedByPeers public="1" set="null"><x path="Float"/></fragmentsRequestedByPeers>
		<fragmentsReceivedFromServer public="1" set="null"><x path="Float"/></fragmentsReceivedFromServer>
		<fragmentsReceivedFromIPMulticast public="1" set="null"><x path="Float"/></fragmentsReceivedFromIPMulticast>
		<fragmentsPushedToPeers public="1" set="null"><x path="Float"/></fragmentsPushedToPeers>
		<fragmentsPushedFromPeers public="1" set="null"><x path="Float"/></fragmentsPushedFromPeers>
		<bytesRequestedFromPeers public="1" set="null"><x path="Float"/></bytesRequestedFromPeers>
		<bytesRequestedByPeers public="1" set="null"><x path="Float"/></bytesRequestedByPeers>
		<bytesReceivedFromServer public="1" set="null"><x path="Float"/></bytesReceivedFromServer>
		<bytesReceivedFromIPMulticast public="1" set="null"><x path="Float"/></bytesReceivedFromIPMulticast>
		<bytesPushedToPeers public="1" set="null"><x path="Float"/></bytesPushedToPeers>
		<bytesPushedFromPeers public="1" set="null"><x path="Float"/></bytesPushedFromPeers>
		<new public="1"><f a="sendDataBytesPerSecond:sendControlBytesPerSecond:receiveDataBytesPerSecond:receiveControlBytesPerSecond:bytesPushedToPeers:fragmentsPushedToPeers:bytesRequestedByPeers:fragmentsRequestedByPeers:bytesPushedFromPeers:fragmentsPushedFromPeers:bytesRequestedFromPeers:fragmentsRequestedFromPeers:sendControlBytesPerSecondToServer:receiveDataBytesPerSecondFromServer:bytesReceivedFromServer:fragmentsReceivedFromServer:receiveDataBytesPerSecondFromIPMulticast:bytesReceivedFromIPMulticast:fragmentsReceivedFromIPMulticast">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":final"/>
			<m n=":require"><e>flash10_1</e></m>
		</meta>
	</class>
	<class path="flash.net.NetStreamPlayOptions" params="" file="/usr/lib/haxe/std/flash/net/NetStreamPlayOptions.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transition public="1"><c path="String"/></transition>
		<streamName public="1"><c path="String"/></streamName>
		<start public="1"><x path="Float"/></start>
		<oldStreamName public="1"><c path="String"/></oldStreamName>
		<len public="1"><x path="Float"/></len>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.net.Responder" params="" file="/usr/lib/haxe/std/flash/net/Responder.hx" extern="1"><new public="1" set="method"><f a="result:?status">
	<d/>
	<d/>
	<x path="Void"/>
</f></new></class>
	<class path="flash.net.URLLoader" params="" file="/usr/lib/haxe/std/flash/net/URLLoader.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<load public="1" set="method"><f a="request">
	<c path="flash.net.URLRequest"/>
	<x path="Void"/>
</f></load>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<dataFormat public="1"><e path="flash.net.URLLoaderDataFormat"/></dataFormat>
		<data public="1"><d/></data>
		<bytesTotal public="1"><x path="UInt"/></bytesTotal>
		<bytesLoaded public="1"><x path="UInt"/></bytesLoaded>
		<new public="1" set="method"><f a="?request">
	<c path="flash.net.URLRequest"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.net.URLLoaderDataFormat" params="" file="/usr/lib/haxe/std/flash/net/URLLoaderDataFormat.hx">
		<BINARY/>
		<TEXT/>
		<VARIABLES/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash/net/URLRequest.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<method public="1"><c path="String"/></method>
		<digest public="1"><c path="String"/></digest>
		<data public="1"><d/></data>
		<contentType public="1"><c path="String"/></contentType>
		<new public="1" set="method"><f a="?url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash/net/URLRequestHeader.hx" extern="1">
		<value public="1"><c path="String"/></value>
		<name public="1"><c path="String"/></name>
		<new public="1" set="method"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.net.URLVariables" params="" file="/usr/lib/haxe/std/flash/net/URLVariables.hx" extern="1">
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<decode public="1" set="method"><f a="source">
	<c path="String"/>
	<x path="Void"/>
</f></decode>
		<new public="1" set="method"><f a="?source">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash/system/ApplicationDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<hasDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></hasDefinition>
		<getDefinition public="1" set="method"><f a="name">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getDefinition>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<new public="1" set="method"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.system.Capabilities" params="" file="/usr/lib/haxe/std/flash/system/Capabilities.hx" extern="1">
		<_internal public="1" set="null" static="1"><x path="UInt"/></_internal>
		<avHardwareDisable public="1" set="null" static="1"><x path="Bool"/></avHardwareDisable>
		<hasAccessibility public="1" set="null" static="1"><x path="Bool"/></hasAccessibility>
		<hasAudio public="1" set="null" static="1"><x path="Bool"/></hasAudio>
		<hasAudioEncoder public="1" set="null" static="1"><x path="Bool"/></hasAudioEncoder>
		<hasEmbeddedVideo public="1" set="null" static="1"><x path="Bool"/></hasEmbeddedVideo>
		<hasIME public="1" set="null" static="1"><x path="Bool"/></hasIME>
		<hasMP3 public="1" set="null" static="1"><x path="Bool"/></hasMP3>
		<hasPrinting public="1" set="null" static="1"><x path="Bool"/></hasPrinting>
		<hasScreenBroadcast public="1" set="null" static="1"><x path="Bool"/></hasScreenBroadcast>
		<hasScreenPlayback public="1" set="null" static="1"><x path="Bool"/></hasScreenPlayback>
		<hasStreamingAudio public="1" set="null" static="1"><x path="Bool"/></hasStreamingAudio>
		<hasStreamingVideo public="1" set="null" static="1"><x path="Bool"/></hasStreamingVideo>
		<hasTLS public="1" set="null" static="1"><x path="Bool"/></hasTLS>
		<hasVideoEncoder public="1" set="null" static="1"><x path="Bool"/></hasVideoEncoder>
		<isDebugger public="1" set="null" static="1"><x path="Bool"/></isDebugger>
		<language public="1" set="null" static="1"><c path="String"/></language>
		<localFileReadDisable public="1" set="null" static="1"><x path="Bool"/></localFileReadDisable>
		<manufacturer public="1" set="null" static="1"><c path="String"/></manufacturer>
		<os public="1" set="null" static="1"><c path="String"/></os>
		<pixelAspectRatio public="1" set="null" static="1"><x path="Float"/></pixelAspectRatio>
		<playerType public="1" set="null" static="1"><c path="String"/></playerType>
		<screenColor public="1" set="null" static="1"><c path="String"/></screenColor>
		<screenDPI public="1" set="null" static="1"><x path="Float"/></screenDPI>
		<screenResolutionX public="1" set="null" static="1"><x path="Float"/></screenResolutionX>
		<screenResolutionY public="1" set="null" static="1"><x path="Float"/></screenResolutionY>
		<serverString public="1" set="null" static="1"><c path="String"/></serverString>
		<version public="1" set="null" static="1"><c path="String"/></version>
	</class>
	<enum path="flash.system.ImageDecodingPolicy" params="" file="/usr/lib/haxe/std/flash/system/ImageDecodingPolicy.hx">
		<ON_DEMAND/>
		<ON_LOAD/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash/system/LoaderContext.hx" extern="1">
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<checkPolicyFile public="1"><x path="Bool"/></checkPolicyFile>
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<new public="1" set="method"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<x path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash/system/SecurityDomain.hx" extern="1"><currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain></class>
	<enum path="flash.system.TouchscreenType" params="" file="/usr/lib/haxe/std/flash/system/TouchscreenType.hx">
		<FINGER/>
		<NONE/>
		<STYLUS/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash/text/AntiAliasType.hx">
		<ADVANCED/>
		<NORMAL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash/text/GridFitType.hx">
		<NONE/>
		<PIXEL/>
		<SUBPIXEL/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<transform public="1" set="method"><f a="formatObject">
	<t path="flash.utils.Object"/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<setStyle public="1" set="method"><f a="styleName:styleObject">
	<c path="String"/>
	<t path="flash.utils.Object"/>
	<x path="Void"/>
</f></setStyle>
		<parseCSS public="1" set="method"><f a="CSSText">
	<c path="String"/>
	<x path="Void"/>
</f></parseCSS>
		<getStyle public="1" set="method"><f a="styleName">
	<c path="String"/>
	<t path="flash.utils.Object"/>
</f></getStyle>
		<clear public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<setTextFormat public="1" set="method"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setTextFormat>
		<setSelection public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setSelection>
		<replaceText public="1" set="method"><f a="beginIndex:endIndex:newText">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Void"/>
</f></replaceText>
		<replaceSelectedText public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></replaceSelectedText>
		<pasteRichText public="1" set="method"><f a="richText">
	<c path="String"/>
	<x path="Bool"/>
</f></pasteRichText>
		<insertXMLText public="1" set="method"><f a="beginIndex:endIndex:richText:?pasting">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></insertXMLText>
		<getXMLText public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<getTextRuns public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getTextFormat public="1" set="method"><f a="?beginIndex:?endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getRawText public="1" set="method"><f a=""><c path="String"/></f></getRawText>
		<getParagraphLength public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getParagraphLength>
		<getLineText public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getLineOffset public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineOffset>
		<getLineMetrics public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineLength public="1" set="method"><f a="lineIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineLength>
		<getLineIndexOfChar public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getLineIndexOfChar>
		<getLineIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getLineIndexAtPoint>
		<getImageReference public="1" set="method"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getFirstCharInParagraph public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<x path="Int"/>
</f></getFirstCharInParagraph>
		<getCharIndexAtPoint public="1" set="method"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
</f></getCharIndexAtPoint>
		<getCharBoundaries public="1" set="method"><f a="charIndex">
	<x path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<copyRichText public="1" set="method"><f a=""><c path="String"/></f></copyRichText>
		<appendText public="1" set="method"><f a="newText">
	<c path="String"/>
	<x path="Void"/>
</f></appendText>
		<wordWrap public="1"><x path="Bool"/></wordWrap>
		<useRichTextClipboard public="1"><x path="Bool"/></useRichTextClipboard>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<thickness public="1"><x path="Float"/></thickness>
		<textWidth public="1" set="null"><x path="Float"/></textWidth>
		<textHeight public="1" set="null"><x path="Float"/></textHeight>
		<textColor public="1"><x path="UInt"/></textColor>
		<text public="1"><c path="String"/></text>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<sharpness public="1"><x path="Float"/></sharpness>
		<selectionEndIndex public="1" set="null"><x path="Int"/></selectionEndIndex>
		<selectionBeginIndex public="1" set="null"><x path="Int"/></selectionBeginIndex>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectable public="1"><x path="Bool"/></selectable>
		<scrollV public="1"><x path="Int"/></scrollV>
		<scrollH public="1"><x path="Int"/></scrollH>
		<restrict public="1"><c path="String"/></restrict>
		<numLines public="1" set="null"><x path="Int"/></numLines>
		<multiline public="1"><x path="Bool"/></multiline>
		<mouseWheelEnabled public="1"><x path="Bool"/></mouseWheelEnabled>
		<maxScrollV public="1" set="null"><x path="Int"/></maxScrollV>
		<maxScrollH public="1" set="null"><x path="Int"/></maxScrollH>
		<maxChars public="1"><x path="Int"/></maxChars>
		<length public="1" set="null"><x path="Int"/></length>
		<htmlText public="1"><c path="String"/></htmlText>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<embedFonts public="1"><x path="Bool"/></embedFonts>
		<displayAsPassword public="1"><x path="Bool"/></displayAsPassword>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<condenseWhite public="1"><x path="Bool"/></condenseWhite>
		<caretIndex public="1" set="null"><x path="Int"/></caretIndex>
		<bottomScrollV public="1" set="null"><x path="Int"/></bottomScrollV>
		<borderColor public="1"><x path="UInt"/></borderColor>
		<border public="1"><x path="Bool"/></border>
		<backgroundColor public="1"><x path="UInt"/></backgroundColor>
		<background public="1"><x path="Bool"/></background>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<alwaysShowSelection public="1"><x path="Bool"/></alwaysShowSelection>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash/text/TextFieldAutoSize.hx">
		<CENTER/>
		<LEFT/>
		<NONE/>
		<RIGHT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash/text/TextFieldType.hx">
		<DYNAMIC/>
		<INPUT/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash/text/TextFormat.hx" extern="1">
		<url public="1"><c path="String"/></url>
		<underline public="1"><t path="Null"><x path="Bool"/></t></underline>
		<target public="1"><c path="String"/></target>
		<tabStops public="1"><c path="Array"><x path="UInt"/></c></tabStops>
		<size public="1"><t path="Null"><x path="Float"/></t></size>
		<rightMargin public="1"><t path="Null"><x path="Float"/></t></rightMargin>
		<letterSpacing public="1"><t path="Null"><x path="Float"/></t></letterSpacing>
		<leftMargin public="1"><t path="Null"><x path="Float"/></t></leftMargin>
		<leading public="1"><t path="Null"><x path="Float"/></t></leading>
		<kerning public="1"><t path="Null"><x path="Bool"/></t></kerning>
		<italic public="1"><t path="Null"><x path="Bool"/></t></italic>
		<indent public="1"><t path="Null"><x path="Float"/></t></indent>
		<font public="1"><c path="String"/></font>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<color public="1"><t path="Null"><x path="UInt"/></t></color>
		<bullet public="1"><t path="Null"><x path="Bool"/></t></bullet>
		<bold public="1"><t path="Null"><x path="Bool"/></t></bold>
		<blockIndent public="1"><t path="Null"><x path="Float"/></t></blockIndent>
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<new public="1" set="method"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<x path="Float"/>
	<x path="UInt"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<c path="String"/>
	<e path="flash.text.TextFormatAlign"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash/text/TextFormatAlign.hx">
		<CENTER/>
		<END/>
		<JUSTIFY/>
		<LEFT/>
		<RIGHT/>
		<START/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash/text/TextFormatDisplay.hx">
		<BLOCK/>
		<INLINE/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<enum path="flash.text.TextInteractionMode" params="" file="/usr/lib/haxe/std/flash/text/TextInteractionMode.hx">
		<NORMAL/>
		<SELECTION/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash/text/TextLineMetrics.hx" extern="1">
		<x public="1"><x path="Float"/></x>
		<width public="1"><x path="Float"/></width>
		<leading public="1"><x path="Float"/></leading>
		<height public="1"><x path="Float"/></height>
		<descent public="1"><x path="Float"/></descent>
		<ascent public="1"><x path="Float"/></ascent>
		<new public="1" set="method"><f a="x:width:height:ascent:descent:leading">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash/text/TextSnapshot.hx" extern="1">
		<setSelected public="1" set="method"><f a="beginIndex:endIndex:select">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSelected>
		<setSelectColor public="1" set="method"><f a="?hexColor">
	<x path="UInt"/>
	<x path="Void"/>
</f></setSelectColor>
		<hitTestTextNearPos public="1" set="method"><f a="x:y:?maxDistance">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></hitTestTextNearPos>
		<getTextRunInfo public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<getText public="1" set="method"><f a="beginIndex:endIndex:?includeLineEndings">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
	<c path="String"/>
</f></getText>
		<getSelectedText public="1" set="method"><f a="?includeLineEndings">
	<x path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getSelected public="1" set="method"><f a="beginIndex:endIndex">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Bool"/>
</f></getSelected>
		<findText public="1" set="method"><f a="beginIndex:textToFind:caseSensitive">
	<x path="Int"/>
	<c path="String"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></findText>
		<charCount public="1" set="null"><x path="Int"/></charCount>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenu.hx" extern="1">
		<extends path="flash.display.NativeMenu"/>
		<hideBuiltInItems public="1" set="method"><f a=""><x path="Void"/></f></hideBuiltInItems>
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuBuiltInItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<zoom public="1"><x path="Bool"/></zoom>
		<save public="1"><x path="Bool"/></save>
		<rewind public="1"><x path="Bool"/></rewind>
		<quality public="1"><x path="Bool"/></quality>
		<print public="1"><x path="Bool"/></print>
		<play public="1"><x path="Bool"/></play>
		<loop public="1"><x path="Bool"/></loop>
		<forwardAndBack public="1"><x path="Bool"/></forwardAndBack>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.ui.ContextMenuClipboardItems" params="" file="/usr/lib/haxe/std/flash/ui/ContextMenuClipboardItems.hx" extern="1">
		<clone public="1" set="method"><f a=""><c path="flash.ui.ContextMenuClipboardItems"/></f></clone>
		<selectAll public="1"><x path="Bool"/></selectAll>
		<paste public="1"><x path="Bool"/></paste>
		<cut public="1"><x path="Bool"/></cut>
		<copy public="1"><x path="Bool"/></copy>
		<clear public="1"><x path="Bool"/></clear>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":final"/></meta>
	</class>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput.hx" extern="1" interface="1">
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
	</class>
	<class path="flash.utils.IDataInput2" params="" file="/usr/lib/haxe/std/flash/utils/IDataInput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataInput"/></class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput.hx" extern="1" interface="1">
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
	</class>
	<class path="flash.utils.IDataOutput2" params="" file="/usr/lib/haxe/std/flash/utils/IDataOutput2.hx" extern="1" interface="1"><extends path="flash.utils.IDataOutput"/></class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataInput2"/>
		<implements path="flash.utils.IDataOutput2"/>
		<defaultObjectEncoding public="1" static="1"><x path="UInt"/></defaultObjectEncoding>
		<writeUnsignedInt public="1" set="method"><f a="value">
	<x path="UInt"/>
	<x path="Void"/>
</f></writeUnsignedInt>
		<writeUTFBytes public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTFBytes>
		<writeUTF public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></writeUTF>
		<writeShort public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeShort>
		<writeObject public="1" set="method"><f a="object">
	<d/>
	<x path="Void"/>
</f></writeObject>
		<writeMultiByte public="1" set="method"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></writeMultiByte>
		<writeInt public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeInt>
		<writeFloat public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeFloat>
		<writeDouble public="1" set="method"><f a="value">
	<x path="Float"/>
	<x path="Void"/>
</f></writeDouble>
		<writeBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></writeBytes>
		<writeByte public="1" set="method"><f a="value">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBoolean public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></writeBoolean>
		<uncompress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></uncompress>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<readUnsignedShort public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedShort>
		<readUnsignedInt public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedInt>
		<readUnsignedByte public="1" set="method"><f a=""><x path="UInt"/></f></readUnsignedByte>
		<readUTFBytes public="1" set="method"><f a="length">
	<x path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUTF public="1" set="method"><f a=""><c path="String"/></f></readUTF>
		<readShort public="1" set="method"><f a=""><x path="Int"/></f></readShort>
		<readObject public="1" set="method"><f a=""><d/></f></readObject>
		<readMultiByte public="1" set="method"><f a="length:charSet">
	<x path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readInt public="1" set="method"><f a=""><x path="Int"/></f></readInt>
		<readFloat public="1" set="method"><f a=""><x path="Float"/></f></readFloat>
		<readDouble public="1" set="method"><f a=""><x path="Float"/></f></readDouble>
		<readBytes public="1" set="method"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<x path="UInt"/>
	<x path="UInt"/>
	<x path="Void"/>
</f></readBytes>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBoolean public="1" set="method"><f a=""><x path="Bool"/></f></readBoolean>
		<compress public="1" set="method"><f a="?algorithm">
	<e path="flash.utils.CompressionAlgorithm"/>
	<x path="Void"/>
</f></compress>
		<position public="1"><x path="UInt"/></position>
		<objectEncoding public="1"><x path="UInt"/></objectEncoding>
		<length public="1"><x path="UInt"/></length>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<bytesAvailable public="1" set="null"><x path="UInt"/></bytesAvailable>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="flash.utils.CompressionAlgorithm" params="" file="/usr/lib/haxe/std/flash/utils/CompressionAlgorithm.hx">
		<DEFLATE/>
		<LZMA/>
		<ZLIB/>
		<meta>
			<m n=":fakeEnum"><e>String</e></m>
			<m n=":require"><e>flash11</e></m>
		</meta>
	</enum>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash/utils/Dictionary.hx" extern="1">
		<new public="1" set="method"><f a="?weakKeys">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash/utils/Endian.hx">
		<BIG_ENDIAN/>
		<LITTLE_ENDIAN/>
		<meta><m n=":fakeEnum"><e>String</e></m></meta>
	</enum>
	<typedef path="flash.utils.Function" params="" file="/usr/lib/haxe/std/flash/utils/Function.hx"><d/></typedef>
	<class path="flash.utils.Namespace" params="" file="/usr/lib/haxe/std/flash/utils/Namespace.hx" extern="1">
		<uri public="1" set="null"><c path="String"/></uri>
		<prefix public="1" set="null"><d/></prefix>
		<new public="1" set="method"><f a="?prefix:?uri">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<typedef path="flash.utils.Object" params="" file="/usr/lib/haxe/std/flash/utils/Object.hx"><d/></typedef>
	<class path="flash.utils.RegExp" params="" file="/usr/lib/haxe/std/flash/utils/RegExp.hx" extern="1">
		<test public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</test>
		<exec public="1" set="method">
			<f a="?s">
				<c path="String"/>
				<d/>
			</f>
			<meta><m n=":ns"><e>"http://adobe.com/AS3/2006/builtin"</e></m></meta>
		</exec>
		<source public="1" set="null"><c path="String"/></source>
		<multiline public="1" set="null"><x path="Bool"/></multiline>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<ignoreCase public="1" set="null"><x path="Bool"/></ignoreCase>
		<global public="1" set="null"><x path="Bool"/></global>
		<extended public="1" set="null"><x path="Bool"/></extended>
		<dotall public="1" set="null"><x path="Bool"/></dotall>
		<new public="1" set="method"><f a="?pattern:?options">
	<d/>
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash/xml/XML.hx" extern="1">
		<ignoreComments public="1" static="1"><x path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><x path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><x path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><x path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><x path="Bool"/></prettyPrinting>
		<defaultSettings public="1" set="method" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" set="method" static="1"><f a="?o">
	<d/>
	<x path="Void"/>
</f></setSettings>
		<settings public="1" set="method" static="1"><f a=""><d/></f></settings>
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNotification public="1" set="method"><f a="f">
	<t path="flash.utils.Function"/>
	<d/>
</f></setNotification>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<notification public="1" set="method"><f a=""><t path="flash.utils.Function"/></f></notification>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash/xml/XMLList.hx" extern="1">
		<valueOf public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<toXMLString public="1" set="method"><f a=""><c path="String"/></f></toXMLString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<text public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<setNamespace public="1" set="method"><f a="ns">
	<d/>
	<x path="Void"/>
</f></setNamespace>
		<setName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setName>
		<setLocalName public="1" set="method"><f a="name">
	<d/>
	<x path="Void"/>
</f></setLocalName>
		<setChildren public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<replace public="1" set="method"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<removeNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<processingInstructions public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<prependChild public="1" set="method"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<parent public="1" set="method"><f a=""><c path="flash.xml.XML"/></f></parent>
		<normalize public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<nodeKind public="1" set="method"><f a=""><c path="String"/></f></nodeKind>
		<namespaceDeclarations public="1" set="method"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<namespace public="1" set="method"><f a="?prefix">
	<d/>
	<c path="flash.utils.Namespace"/>
</f></namespace>
		<name public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></name>
		<localName public="1" set="method"><f a=""><t path="flash.utils.Object"/></f></localName>
		<length public="1" set="method"><f a=""><x path="Int"/></f></length>
		<insertChildBefore public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildBefore>
		<insertChildAfter public="1" set="method"><f a="child1:child2">
	<d/>
	<d/>
	<d/>
</f></insertChildAfter>
		<inScopeNamespaces public="1" set="method"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<hasSimpleContent public="1" set="method"><f a=""><x path="Bool"/></f></hasSimpleContent>
		<hasComplexContent public="1" set="method"><f a=""><x path="Bool"/></f></hasComplexContent>
		<elements public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<descendants public="1" set="method"><f a="?name">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<copy public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<contains public="1" set="method"><f a="value">
	<d/>
	<x path="Bool"/>
</f></contains>
		<comments public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<children public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<childIndex public="1" set="method"><f a=""><x path="Int"/></f></childIndex>
		<child public="1" set="method"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<attributes public="1" set="method"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<attribute public="1" set="method"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<appendChild public="1" set="method"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<addNamespace public="1" set="method"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<new public="1" set="method"><f a="?value">
	<d/>
	<x path="Void"/>
</f></new>
		<meta><m n=":final"/></meta>
	</class>
	<enum path="haxe.StackItem" params="" file="/usr/lib/haxe/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line">
			<t path="Null"><e path="haxe.StackItem"/></t>
			<c path="String"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<c path="String"/>
			<c path="String"/>
		</Method>
		<Lambda a="v"><x path="Int"/></Lambda>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
	</enum>
	<class path="haxe.CallStack" params="" file="/usr/lib/haxe/std/haxe/CallStack.hx">
		<callStack public="1" set="method" line="43" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the call stack elements, or an empty array if not available.</haxe_doc>
		</callStack>
		<exceptionStack public="1" set="method" line="94" static="1">
			<f a=""><c path="Array"><e path="haxe.StackItem"/></c></f>
			<haxe_doc>Return the exception stack : this is the stack elements between
		the place the last exception was thrown and the place it was
		caught, or an empty array if not available.</haxe_doc>
		</exceptionStack>
		<makeStack set="method" line="164" static="1"><f a="s">
	<c path="String"/>
	<c path="Array"><e path="haxe.StackItem"/></c>
</f></makeStack>
		<haxe_doc>Get informations about the call stack.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="41" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.
		
		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a haxe module, that module is not part of the
		package structure.
			
		If `e` has no package, the enum name is returned.
		
		If `e` is null, the result is unspecified.
		
		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="54" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="70" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.
		
		The constructor indices are preserved from haxe syntax, so the first
		declared is index 0, the next index 1 etc.
		
		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="87" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.
		
		This may return the empty Array [] if all constructors of `e` require
		arguments.
		
		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="99" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.
		
		The order of the constructor names in the returned Array is preserved
		from the original syntax.
		
		If `c` is null, the result is unspecified.</haxe_doc>
		</getConstructors>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/lib/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="114" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.
		
		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.
		
		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="125" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.
		
		The result String does not contain any constructor arguments.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="139" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.
		
		If `e` has no arguments, the result is [].
		
		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="151" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.
		
		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.
		
		If `e` is null, the result is unspecified.</haxe_doc>
		</getIndex>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" set="dynamic" line="45" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the trace() call was made.

		This method can be rebound to a custom function:
			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v,infos) { // handle trace }
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to trace() will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the trace() method, which is invoked upon a call to
	trace() in haxe code.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<c path="Array"><d/></c>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.
	
	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.
	
	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx">
		<this><a>
	<values><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.V"/></c></values>
	<keys><c path="haxe.ds.IntMap"><c path="haxe.ds.HashMap.K"/></c></keys>
</a></this>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/lib/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/usr/lib/haxe/std/flash/_std/haxe/ds/StringMap.hx">
		<implements path="IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.
	
	See `Map` for documentation details.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="haxe.rtti.Meta" params="" file="/usr/lib/haxe/std/haxe/rtti/Meta.hx">
		<getFields public="1" set="method" line="56" static="1">
			<f a="t">
				<d/>
				<d><d><c path="Array"><d/></c></d></d>
			</f>
			<haxe_doc>Returns the metadata that were declared for the given class fields or enum constructors</haxe_doc>
		</getFields>
		<haxe_doc>An api to access classes and enums metadata at runtime.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="massive.haxe.Exception" params="" file="/usr/lib/haxe/lib/mlib/2,0,2/massive/haxe/Exception.hx">
		<toString public="1" set="method" line="78">
			<f a=""><c path="String"/></f>
			<haxe_doc><![CDATA[* Returns a string representation of this exception.
	 * 
	 * Format: <type>: <message> at <className>#<methodName> (<lineNumber>)]]></haxe_doc>
		</toString>
		<info public="1" set="null">
			<t path="haxe.PosInfos"/>
			<haxe_doc>* The pos infos from where the exception was created.</haxe_doc>
		</info>
		<message public="1" set="null">
			<c path="String"/>
			<haxe_doc>* A description of the exception</haxe_doc>
		</message>
		<type public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The exception type. 
	 * 
	 * Should be the fully qualified name of the Exception class. e.g. 'massive.io.IOException'</haxe_doc>
		</type>
		<new public="1" set="method" line="66">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	message			a description of the exception</haxe_doc>
		</new>
		<haxe_doc>* Instances of the class Exception and its subclasses, when thrown, provide information about
 * the type and location of erroneous behavior.
 * 
 * An application should lookout for and handle raised exceptions through try/catch blocks located
 * in an appropriate place.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.haxe.util.ReflectUtil" params="" file="/usr/lib/haxe/lib/mlib/2,0,2/massive/haxe/util/ReflectUtil.hx">
		<here public="1" set="method" line="43" static="1">
			<f a="?info">
				<t path="haxe.PosInfos"/>
				<t path="haxe.PosInfos"/>
			</f>
			<haxe_doc>* Return information about the location this method is called.</haxe_doc>
		</here>
		<haxe_doc>* Utility class to help with reflection.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.Assert" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/Assert.hx">
		<assertionCount public="1" line="43" static="1">
			<x path="Int"/>
			<haxe_doc>* The incremented number of assertions made during the execution of a set of tests.</haxe_doc>
		</assertionCount>
		<isTrue public="1" set="method" line="51" static="1">
			<f a="value:?info">
				<x path="Bool"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is true.
	 *  
	 * @param	value				value expected to be true
	 * @throws	AssertionException	if value is not true</haxe_doc>
		</isTrue>
		<isFalse public="1" set="method" line="63" static="1">
			<f a="value:?info">
				<x path="Bool"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is false.
	 *  
	 * @param	value				value expected to be false
	 * @throws	AssertionException	if value is not false</haxe_doc>
		</isFalse>
		<isNull public="1" set="method" line="75" static="1">
			<f a="value:?info">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is null.
	 *  
	 * @param	value				value expected to be null
	 * @throws	AssertionException	if value is not null</haxe_doc>
		</isNull>
		<isNotNull public="1" set="method" line="87" static="1">
			<f a="value:?info">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is not null.
	 *  
	 * @param	value				value expected not to be null
	 * @throws	AssertionException	if value is null</haxe_doc>
		</isNotNull>
		<isNaN public="1" set="method" line="99" static="1">
			<f a="value:?info">
				<x path="Float"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is Math.NaN.
	 *  
	 * @param	value				value expected to be Math.NaN
	 * @throws	AssertionException	if value is not Math.NaN</haxe_doc>
		</isNaN>
		<isNotNaN public="1" set="method" line="111" static="1">
			<f a="value:?info">
				<x path="Float"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is not Math.NaN.
	 *  
	 * @param	value				value expected not to be Math.NaN
	 * @throws	AssertionException	if value is Math.NaN</haxe_doc>
		</isNotNaN>
		<isType public="1" set="method" line="123" static="1">
			<f a="value:type:?info">
				<d/>
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is of a specific type.
	 * 
	 * @param	value				value expected to be of a given type
	 * @param	type				type the value should be</haxe_doc>
		</isType>
		<isNotType public="1" set="method" line="135" static="1">
			<f a="value:type:?info">
				<d/>
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that a value is not of a specific type.
	 * 
	 * @param	value				value expected to not be of a given type
	 * @param	type				type the value should not be</haxe_doc>
		</isNotType>
		<areEqual public="1" set="method" line="151" static="1">
			<f a="expected:actual:?info">
				<d/>
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that two values are equal.
	 * 
	 * If the expected value is an Enum then Type.enumEq will be used to compare the two values.
	 * Otherwise strict equality is used.
	 *  
	 * @param	expected			expected value
	 * @param	actual				actual value
	 * @throws	AssertionException	if expected is not equal to the actual value</haxe_doc>
		</areEqual>
		<areNotEqual public="1" set="method" line="177" static="1">
			<f a="expected:actual:?info">
				<d/>
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that two values are not equal.
	 *  
	 * If the expected value is an Enum then Type.enumEq will be used to compare the two values.
	 * Otherwise strict equality is used.
	 *  
	 * @param	expected			expected value
	 * @param	actual				actual value
	 * @throws	AssertionException	if expected is equal to the actual value</haxe_doc>
		</areNotEqual>
		<areSame public="1" set="method" line="200" static="1">
			<f a="expected:actual:?info">
				<d/>
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that two values are one and the same.
	 *  
	 * @param	expected			expected value
	 * @param	actual				actual value
	 * @throws	AssertionException	if expected is not the same as the actual value</haxe_doc>
		</areSame>
		<areNotSame public="1" set="method" line="213" static="1">
			<f a="expected:actual:?info">
				<d/>
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Assert that two values are not one and the same.
	 *  
	 * @param	expected			expected value
	 * @param	actual				actual value
	 * @throws	AssertionException	if expected is the same as the actual value</haxe_doc>
		</areNotSame>
		<fail public="1" set="method" line="225" static="1">
			<f a="msg:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Force an assertion failure.
	  *  
	  * @param	msg				message describing the assertion which failed
	  * @throws	AssertionException	thrown automatically</haxe_doc>
		</fail>
		<haxe_doc>* Used to make assertions about values in test cases.
 *  
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.MUnitException" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/MUnitException.hx">
		<extends path="massive.haxe.Exception"/>
		<new public="1" set="method" line="47">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
	 * 
	 * @param	message			a description of the exception
	 * @param	info			pos infos from where the exception was thrown</haxe_doc>
		</new>
		<haxe_doc>* Base exception type for all exceptions raised by munit.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.AssertionException" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/AssertionException.hx">
		<extends path="massive.munit.MUnitException"/>
		<new public="1" set="method" line="46">
			<f a="msg:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param	msg				message describing the assertion which failed
	 * @param	info			pos infos of where the failing assertion was made</haxe_doc>
		</new>
		<haxe_doc>* Exception thrown when an assertion is made which is not correct.
 *  
 * @author Mike Stead
 * @see Assert</haxe_doc>
	</class>
	<class path="massive.munit.ITestResultClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/ITestResultClient.hx" interface="1">
		<reportFinalStatistics public="1" set="method">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<d/>
			</f>
			<haxe_doc>* Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data if any</haxe_doc>
		</reportFinalStatistics>
		<addIgnore public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test has been ignored.
	 *
	 * @param	result			an ignored test</haxe_doc>
		</addIgnore>
		<addError public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result</haxe_doc>
		</addError>
		<addFail public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test fails.
	 *  
	 * @param	result			a failed test result</haxe_doc>
		</addFail>
		<addPass public="1" set="method">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test passes.
	 *  
	 * @param	result			a passed test result</haxe_doc>
		</addPass>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier for the client.</haxe_doc>
		</id>
		<completionHandler public="1" get="null" set="null">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handler which if present, should be called when the client has completed its processing of the results.</haxe_doc>
		</completionHandler>
		<haxe_doc><![CDATA[* Interface which all test result clients should adhere to.
 * <p>
 * A test result client is responsible for interpreting the results of tests as
 * they are executed by a test runner.
 * </p>
 * 
 * @author Mike Stead
 * @see TestRunner]]></haxe_doc>
	</class>
	<class path="massive.munit.IAdvancedTestResultClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/ITestResultClient.hx" module="massive.munit.ITestResultClient" interface="1">
		<extends path="massive.munit.ITestResultClient"/>
		<setCurrentTestClass public="1" set="method">
			<f a="className">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called before a new test class in run.
	 *
	 * @param	result			a stub test result</haxe_doc>
		</setCurrentTestClass>
		<haxe_doc><![CDATA[* Updated Interface which all test result clients should adhere to.
 * <p>
 * A test result client is responsible for interpreting the results of tests as
 * they are executed by a test runner.
 * </p>
 * 
 * @author Dominic De Lorenzo
 * @see TestRunner]]></haxe_doc>
	</class>
	<class path="massive.munit.ICoverageTestResultClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/ITestResultClient.hx" module="massive.munit.ITestResultClient" interface="1">
		<extends path="massive.munit.IAdvancedTestResultClient"/>
		<reportFinalCoverage public="1" set="method">
			<f a="?percent:missingCoverageResults:summary:?classBreakdown:?packageBreakdown:?executionFrequency">
				<x path="Float"/>
				<c path="Array"><t path="massive.munit.CoverageResult"/></c>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called after all test classes have finished
	 *
	 * @param	percent					overall coverage percentage
	 * @param	coverageResults			missing coverage results
	 * @param	summary					high level coverage report
	 * @param	classBreakdown			results per class
 	 * @param	packageBreakdown		results per package
	 * @param	executionFrequency		statement/branch frequency</haxe_doc>
		</reportFinalCoverage>
		<setCurrentTestClassCoverage public="1" set="method">
			<f a="result">
				<t path="massive.munit.CoverageResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called after all tests have completed for current class
	 *
	 * @param	result			missing class coverage covered by tests</haxe_doc>
		</setCurrentTestClassCoverage>
		<haxe_doc>* Interface for supporting test coverage
 * 
 * @author Dominic De Lorenzo
 * @see TestRunner</haxe_doc>
	</class>
	<typedef path="massive.munit.CoverageResult" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/ITestResultClient.hx" module="massive.munit.ITestResultClient"><a>
	<percent><x path="Float"/></percent>
	<className><c path="String"/></className>
	<blocks><c path="Array"><c path="String"/></c></blocks>
</a></typedef>
	<class path="massive.munit.TestClassHelper" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/TestClassHelper.hx">
		<META_TAG_BEFORE_CLASS public="1" get="inline" set="null" line="51" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking method to be called before all tests in a class.</haxe_doc>
		</META_TAG_BEFORE_CLASS>
		<META_TAG_AFTER_CLASS public="1" get="inline" set="null" line="56" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking method to be called after all tests in a class.</haxe_doc>
		</META_TAG_AFTER_CLASS>
		<META_TAG_BEFORE public="1" get="inline" set="null" line="61" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking method to be called before each test in a class.</haxe_doc>
		</META_TAG_BEFORE>
		<META_TAG_AFTER public="1" get="inline" set="null" line="66" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking method to be called after each test in a class.</haxe_doc>
		</META_TAG_AFTER>
		<META_TAG_TEST public="1" get="inline" set="null" line="71" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking test method in class.</haxe_doc>
		</META_TAG_TEST>
		<META_TAG_ASYNC_TEST public="1" get="inline" set="null" line="76" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking asynchronous test method in class.</haxe_doc>
		</META_TAG_ASYNC_TEST>
		<META_TAG_IGNORE public="1" get="inline" set="null" line="81" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking a test method to ignore.</haxe_doc>
		</META_TAG_IGNORE>
		<META_PARAM_ASYNC_TEST public="1" get="inline" set="null" line="88" static="1">
			<c path="String"/>
			<haxe_doc>* Param for META_TAG_TEST, marking test method in class as asynchronous.
     *
     * @deprecated As of 0.9.1.4, use @AsyncTest instead.</haxe_doc>
		</META_PARAM_ASYNC_TEST>
		<META_TAG_TEST_DEBUG public="1" get="inline" set="null" line="93" static="1">
			<c path="String"/>
			<haxe_doc>* Meta tag marking test method in class for execution in debug mode only.</haxe_doc>
		</META_TAG_TEST_DEBUG>
		<META_TAGS public="1" line="98" static="1">
			<c path="Array"><c path="String"/></c>
			<haxe_doc>* Array of all valid meta tags.</haxe_doc>
		</META_TAGS>
		<nullFunc set="method" line="344"><f a=""><x path="Void"/></f></nullFunc>
		<sortTestsByName set="method" line="337"><f a="x:y">
	<t path="massive.munit.TestCaseData"/>
	<t path="massive.munit.TestCaseData"/>
	<x path="Int"/>
</f></sortTestsByName>
		<addTest set="method" line="320"><f a="field:testFunction:testInstance:isAsync:isIgnored:description">
	<c path="String"/>
	<d/>
	<d/>
	<x path="Bool"/>
	<x path="Bool"/>
	<c path="String"/>
	<x path="Void"/>
</f></addTest>
		<searchForMatchingTags set="method" line="275"><f a="fieldName:func:funcMeta">
	<c path="String"/>
	<d/>
	<d/>
	<x path="Void"/>
</f></searchForMatchingTags>
		<scanForTests set="method" line="261"><f a="fieldMeta">
	<d/>
	<x path="Void"/>
</f></scanForTests>
		<collateFieldMeta set="method" line="210"><f a="inherintanceChain">
	<c path="Array"><x path="Class"><d/></x></c>
	<d/>
</f></collateFieldMeta>
		<getInheritanceChain set="method" line="202"><f a="clazz">
	<x path="Class"><d/></x>
	<c path="Array"><x path="Class"><d/></x></c>
</f></getInheritanceChain>
		<parse set="method" line="192"><f a="type">
	<x path="Class"><d/></x>
	<x path="Void"/>
</f></parse>
		<current public="1" set="method" line="187">
			<f a=""><d/></f>
			<haxe_doc>* Get the current test in the iterable list of tests.
	 * 
	 * @return	current test in the iterable list of tests</haxe_doc>
		</current>
		<next public="1" set="method" line="177">
			<f a=""><d/></f>
			<haxe_doc>* Returns the next test in the iterable list of tests.
	 * 
	 * @return	if another test is available it's returned, otherwise returns null</haxe_doc>
		</next>
		<hasNext public="1" set="method" line="167">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Check if there is another test in the iterable list of tests.
	 * 
	 * @return	true if there is one or more tests available, false if not.</haxe_doc>
		</hasNext>
		<isDebug><x path="Bool"/></isDebug>
		<className public="1" set="null"><c path="String"/></className>
		<index><x path="Int"/></index>
		<tests><c path="Array"><t path="massive.munit.TestCaseData"/></c></tests>
		<after public="1" set="null">
			<d/>
			<haxe_doc>* The life cycle method to be called once, after each test in the class is executed.</haxe_doc>
		</after>
		<before public="1" set="null">
			<d/>
			<haxe_doc>* The life cycle method to be called once, before each test in the class is executed.</haxe_doc>
		</before>
		<afterClass public="1" set="null">
			<d/>
			<haxe_doc>* The life cycle method to be called once, after tests in the class are executed.</haxe_doc>
		</afterClass>
		<beforeClass public="1" set="null">
			<d/>
			<haxe_doc>* The life cycle method to be called once, before tests in the class are executed.</haxe_doc>
		</beforeClass>
		<test public="1" set="null">
			<d/>
			<haxe_doc>* The instance of the test class this helper is wrapping.</haxe_doc>
		</test>
		<type public="1" set="null">
			<x path="Class"><d/></x>
			<haxe_doc>* The type of the test class this helper is wrapping.</haxe_doc>
		</type>
		<new public="1" set="method" line="146">
			<f a="type:?isDebug">
				<x path="Class"><d/></x>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
	 * 
	 * @param	type			type of test class this helper is wrapping</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* A helper used to discover, and provide access to, the test and life cycle methods of a test class.
 * <p>
 * This object implements Iterable methods (http://haxe.org/ref/iterators) for iterating over the test 
 * cases it discovers in a class.
 * </p>
 * <p>
 * <code>for (test in testHelper){ ... }</code>
 * </p>
 * 
 * @author Mike Stead]]></haxe_doc>
	</class>
	<typedef path="massive.munit.TestCaseData" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/TestClassHelper.hx" module="massive.munit.TestClassHelper"><a>
	<test><d/></test>
	<scope><d/></scope>
	<result><c path="massive.munit.TestResult"/></result>
</a></typedef>
	<class path="massive.munit.TestResult" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/TestResult.hx">
		<get_type set="method" line="110"><f a=""><e path="massive.munit.TestResultType"/></f></get_type>
		<type public="1" get="accessor" set="null"><e path="massive.munit.TestResultType"/></type>
		<error public="1">
			<d/>
			<haxe_doc>* If this test was erroneous, the error that was captured.</haxe_doc>
		</error>
		<failure public="1">
			<c path="massive.munit.AssertionException"/>
			<haxe_doc>* If this test failed, the assertion exception that was captured.</haxe_doc>
		</failure>
		<ignore public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the test is ignored or not.</haxe_doc>
		</ignore>
		<async public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the test is asynchronous or not.</haxe_doc>
		</async>
		<get_location set="method" line="68"><f a=""><c path="String"/></f></get_location>
		<location public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>* The fully qualified location of this test. (i.e. package.ClassName#method)</haxe_doc>
		</location>
		<description public="1">
			<c path="String"/>
			<haxe_doc>* An optional description.</haxe_doc>
		</description>
		<className public="1">
			<c path="String"/>
			<haxe_doc>* The name of the class (qualified with package) where the test is located.</haxe_doc>
		</className>
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of the test. This maps to the name of the test method.</haxe_doc>
		</name>
		<executionTime public="1">
			<x path="Float"/>
			<haxe_doc>* The execution time of the test in milliseconds.</haxe_doc>
		</executionTime>
		<passed public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the test passed or not.</haxe_doc>
		</passed>
		<new public="1" set="method" line="97">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Class constructor.</haxe_doc>
		</new>
		<haxe_doc>* The value object which contains the result of a test.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<enum path="massive.munit.TestResultType" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/TestResult.hx" module="massive.munit.TestResult">
		<UNKNOWN/>
		<PASS/>
		<FAIL/>
		<ERROR/>
		<IGNORE/>
	</enum>
	<class path="massive.munit.async.IAsyncDelegateObserver" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/async/IAsyncDelegateObserver.hx" interface="1">
		<asyncDelegateCreatedHandler public="1" set="method">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when AsyncDelegate is generated through the AsyncFactory.
	 * Enables an observer to cancel any pending async handlers.
	 *
	 * @param	delegate		delegate which received the successful callback</haxe_doc>
		</asyncDelegateCreatedHandler>
		<asyncTimeoutHandler public="1" set="method">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when an AsyncDelegate being observed does not receive its asynchronous callback
	 * in the time allowed.
	 * 
	 * @param	delegate		delegate whose asynchronous callback timed out</haxe_doc>
		</asyncTimeoutHandler>
		<asyncResponseHandler public="1" set="method">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when an AsyncDelegate being observed receives a successful asynchronous callback.
	 * 
	 * @param	delegate		delegate which received the successful callback</haxe_doc>
		</asyncResponseHandler>
		<haxe_doc>* Interface which observers of an AsyncDelegate should implement.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.TestRunner" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/TestRunner.hx">
		<implements path="massive.munit.async.IAsyncDelegateObserver"/>
		<createAsyncFactory set="method" line="425"><f a=""><c path="massive.munit.async.AsyncFactory"/></f></createAsyncFactory>
		<asyncDelegateCreatedHandler public="1" set="method" line="420"><f a="delegate">
	<c path="massive.munit.async.AsyncDelegate"/>
	<x path="Void"/>
</f></asyncDelegateCreatedHandler>
		<asyncTimeoutHandler public="1" set="method" line="405">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when an AsyncDelegate being observed does not receive its asynchronous callback
     * in the time allowed.
     *
     * @param	delegate		delegate whose asynchronous callback timed out</haxe_doc>
		</asyncTimeoutHandler>
		<asyncResponseHandler public="1" set="method" line="386">
			<f a="delegate">
				<c path="massive.munit.async.AsyncDelegate"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when an AsyncDelegate being observed receives a successful asynchronous callback.
     *
     * @param	delegate		delegate which received the successful callback</haxe_doc>
		</asyncResponseHandler>
		<clientCompletionHandler set="method" line="366"><f a="resultClient">
	<c path="massive.munit.ITestResultClient"/>
	<x path="Void"/>
</f></clientCompletionHandler>
		<executeTestCase set="method" line="305"><f a="testCaseData:async">
	<d/>
	<x path="Bool"/>
	<x path="Void"/>
</f></executeTestCase>
		<executeTestCases set="method" line="273"><f a=""><x path="Void"/></f></executeTestCases>
		<execute set="method" line="233"><f a=""><x path="Void"/></f></execute>
		<run public="1" set="method" line="189">
			<f a="testSuiteClasses">
				<c path="Array"><x path="Class"><c path="massive.munit.TestSuite"/></x></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Run one or more suites of unit tests.
     *
     * @param	testSuiteClasses</haxe_doc>
		</run>
		<debug public="1" set="method" line="178">
			<f a="testSuiteClasses">
				<c path="Array"><x path="Class"><c path="massive.munit.TestSuite"/></x></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Run one or more suites of unit tests containing @TestDebug.
     *
     * @param	testSuiteClasses</haxe_doc>
		</debug>
		<addResultClient public="1" set="method" line="164">
			<f a="resultClient">
				<c path="massive.munit.ITestResultClient"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Add one or more result clients to interpret test results.
     *
     * @param	resultClient			a result client to interpret test results</haxe_doc>
		</addResultClient>
		<isDebug set="null"><x path="Bool"/></isDebug>
		<testStartTime><x path="Float"/></testStartTime>
		<startTime><x path="Float"/></startTime>
		<emptyParams><c path="Array"><d/></c></emptyParams>
		<set_asyncFactory set="method" line="124"><f a="value">
	<c path="massive.munit.async.AsyncFactory"/>
	<c path="massive.munit.async.AsyncFactory"/>
</f></set_asyncFactory>
		<asyncFactory public="1" set="accessor"><c path="massive.munit.async.AsyncFactory"/></asyncFactory>
		<suiteIndex><x path="Int"/></suiteIndex>
		<asyncDelegate><c path="massive.munit.async.AsyncDelegate"/></asyncDelegate>
		<asyncPending><x path="Bool"/></asyncPending>
		<testSuites><c path="Array"><c path="massive.munit.TestSuite"/></c></testSuites>
		<activeHelper><c path="massive.munit.TestClassHelper"/></activeHelper>
		<clients><c path="Array"><c path="massive.munit.ITestResultClient"/></c></clients>
		<clientCompleteCount><x path="Int"/></clientCompleteCount>
		<ignoreCount><x path="Int"/></ignoreCount>
		<passCount><x path="Int"/></passCount>
		<errorCount><x path="Int"/></errorCount>
		<failCount><x path="Int"/></failCount>
		<testCount><x path="Int"/></testCount>
		<running public="1" set="null"><x path="Bool"/></running>
		<get_clientCount set="method" line="103"><f a=""><x path="Int"/></f></get_clientCount>
		<clientCount public="1" get="accessor" set="null"><x path="Int"/></clientCount>
		<completionHandler public="1">
			<f a="">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Handler called when all tests have been executed and all clients
     * have completed processing the results.</haxe_doc>
		</completionHandler>
		<new public="1" set="method" line="145">
			<f a="resultClient">
				<c path="massive.munit.ITestResultClient"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
     *
     * @param	resultClient	a result client to interpret test results</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Runner used to execute one or more suites of unit tests.
 *
 * <pre>
 * // Create a test runner with client (PrintClient) and pass it a collection of test suites
 * public class TestMain
 * {
 *     public function new()
 *     {
 *         var suites = new Array<Class<massive.munit.TestSuite>>();
 *         suites.push(TestSuite);
 *
 *         var runner:TestRunner = new TestRunner(new PrintClient());
 *         runner.run(suites);
 *     }
 * }
 *
 * // A test suite with one test class (MathUtilTest)
 * class TestSuite extends massive.unit.TestSuite
 * {
 *     public function new()
 *     {
 *          add(MathUtilTest);
 *     }
 * }
 *
 * // A test class with one test case (testAdd)
 * class MathUtilTest
 * {
 *     @Test
 *     public function testAdd():Void
 *     {
 *         Assert.areEqual(2, MathUtil.add(1,1));
 *     }
 * }
 * </pre>
 * @author Mike Stead
 * @see TestSuite]]></haxe_doc>
	</class>
	<class path="massive.munit.UnhandledException" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/UnhandledException.hx">
		<extends path="massive.munit.MUnitException"/>
		<getStackTrace set="method" line="68"><f a="source">
	<d/>
	<c path="String"/>
</f></getStackTrace>
		<formatLocation set="method" line="56"><f a="source:testLocation">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></formatLocation>
		<new public="1" set="method" line="50">
			<f a="source:testLocation">
				<d/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param source	exception which went unhandled
     * @param location 	test location which triggered exception</haxe_doc>
		</new>
		<haxe_doc>* Exception thrown when a test triggers an exception in code which was not captured.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.async.AsyncDelegate" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/async/AsyncDelegate.hx">
		<DEFAULT_TIMEOUT public="1" get="inline" set="null" line="46" static="1">
			<x path="Int"/>
			<haxe_doc>* Default timeout period in milliseconds.</haxe_doc>
		</DEFAULT_TIMEOUT>
		<actualTimeoutHandler set="method" line="159"><f a=""><x path="Void"/></f></actualTimeoutHandler>
		<timeoutHandler set="method" line="149"><f a=""><x path="Void"/></f></timeoutHandler>
		<delayActualResponseHandler set="method" line="143"><f a=""><x path="Void"/></f></delayActualResponseHandler>
		<responseHandler set="method" line="126"><f a="?params">
	<c path="Array"><d/></c>
	<d/>
</f></responseHandler>
		<cancelTest public="1" set="method" line="119">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cancels pending async timeout.</haxe_doc>
		</cancelTest>
		<runTest public="1" set="method" line="111">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Execute the remainder of the asynchronous test. This should be called after observer
	 * has been notified of a successful asynchronous response.</haxe_doc>
		</runTest>
		<params><c path="Array"><d/></c></params>
		<deferredTimer><c path="massive.munit.util.Timer"/></deferredTimer>
		<canceled public="1" set="null"><x path="Bool"/></canceled>
		<timer><c path="massive.munit.util.Timer"/></timer>
		<handler><d/></handler>
		<testCase><d/></testCase>
		<timedOut public="1" set="null"><x path="Bool"/></timedOut>
		<timeoutDelay public="1" set="null"><x path="Int"/></timeoutDelay>
		<delegateHandler public="1" set="null">
			<d/>
			<haxe_doc><![CDATA[* The handler for a successful response from the asynchronous call.
	 * <p>
	 * This notifies the observer of the success. The observer can then call runTest when
	 * it is ready for the remainder of the async test to be run.
	 * </p>]]></haxe_doc>
		</delegateHandler>
		<info public="1">
			<t path="haxe.PosInfos"/>
			<haxe_doc>* Pos infos of the test which requests an instance of this delegate.</haxe_doc>
		</info>
		<observer public="1">
			<c path="massive.munit.async.IAsyncDelegateObserver"/>
			<haxe_doc>* Observer interested in the outcome of this asynchronous call.</haxe_doc>
		</observer>
		<new public="1" set="method" line="91">
			<f a="testCase:handler:?timeout:?info">
				<d/>
				<d/>
				<x path="Int"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
	 * 
	 * @param	testCase			test case instance where the async test originated
	 * @param	handler				the handler in the test case for a successful async response
	 * @param	?timeout			[optional] number of milliseconds to wait before timing out. Defaults to 400
	 * @param	?info				[optional] pos infos of the test which requests an instance of this delegate</haxe_doc>
		</new>
		<haxe_doc>* Sits between an asynchronous test and an observer (typically the TestRunner), notifying 
 * the observer when an asynchronous test has returned or timed out.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.async.AsyncFactory" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/async/AsyncFactory.hx">
		<createHandler public="1" set="method" line="92">
			<f a="testCase:handler:?timeout:?info">
				<d/>
				<d/>
				<x path="Int"/>
				<t path="haxe.PosInfos"/>
				<d/>
			</f>
			<haxe_doc>* Create an AsyncDelegate which handles variable number of parameters to be passed to its handler.
	 * 
	 * @param	testCase			test case instance where the async test originated
	 * @param	handler				the handler in the test case for a successful async response
	 * @param	?timeout			[optional] number of milliseconds to wait before timing out
	 * @param	?info				[optional] pos infos of the test which requests an instance of this delegate
	 * @return	a delegate function for handling the asynchronous response from an async test case</haxe_doc>
		</createHandler>
		<asyncDelegateCount public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of AsyncDelegates created by this factory.</haxe_doc>
		</asyncDelegateCount>
		<observer public="1">
			<c path="massive.munit.async.IAsyncDelegateObserver"/>
			<haxe_doc>* Observer for all AsyncDelegates this factory creates.</haxe_doc>
		</observer>
		<new public="1" set="method" line="77">
			<f a="observer">
				<c path="massive.munit.async.IAsyncDelegateObserver"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Class constructor.
	 * 
	 * @param	observer			an observer for all AsyncDelegate this factory creates</haxe_doc>
		</new>
		<haxe_doc><![CDATA[* Factory for asynchronous delegates.
 * 
 * <p>
 * An instance of this factory is passed to test methods which define themselves as asynchronous.
 * They can then request a delegate handler to 
 * </p>
 * <pre>
 * class TimerTest
 * {
 *     @Test("Async")
 *     public function testTimer(factory:AsyncFactory):Void
 *     {
 *         var handler:Dynamic = factory.createHandler(this, onTestTimer);
 *         Timer.delay(onTestTimer, 100);
 *     }
 *     
 *     private function onTestTimer():Void
 *     {
 *         Assert.isTrue(true);
 *     }
 * }
 * </pre>
 * 
 * @author Mike Stead]]></haxe_doc>
	</class>
	<class path="massive.munit.async.AsyncTimeoutException" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/async/AsyncTimeoutException.hx">
		<extends path="massive.munit.MUnitException"/>
		<new public="1" set="method" line="44">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* {@inheritDoc}</haxe_doc>
		</new>
		<haxe_doc>* Exception thrown when a test makes an assertion which is incorrect.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.async.MissingAsyncDelegateException" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/async/MissingAsyncDelegateException.hx">
		<extends path="massive.munit.MUnitException"/>
		<new public="1" set="method" line="44">
			<f a="message:?info">
				<c path="String"/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* {@inheritDoc}</haxe_doc>
		</new>
		<haxe_doc>* Exception thrown when an asynchronous test does not create an AsyncDelegate.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.client.AbstractTestResultClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/AbstractTestResultClient.hx">
		<implements path="massive.munit.ICoverageTestResultClient"/>
		<implements path="massive.munit.IAdvancedTestResultClient"/>
		<traces static="1"><c path="Array"><c path="String"/></c></traces>
		<sortTestResults set="method" line="310"><f a="a:b">
	<c path="massive.munit.TestResult"/>
	<c path="massive.munit.TestResult"/>
	<x path="Int"/>
</f></sortTestResults>
		<getTraces set="method" line="305">
			<f a=""><c path="Array"><c path="String"/></c></f>
			<haxe_doc>* returns the current class trace statements</haxe_doc>
		</getTraces>
		<addTrace set="method" line="296"><f a="value:?info">
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></addTrace>
		<printOverallResult set="method" line="289"><f a="result">
	<x path="Bool"/>
	<x path="Void"/>
</f></printOverallResult>
		<printFinalStatistics set="method" line="284">
			<f a="result:testCount:passCount:failCount:errorCount:ignoreCount:time">
				<x path="Bool"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Override to print final summary</haxe_doc>
		</printFinalStatistics>
		<printReports set="method" line="276">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Override to print any additional reports (e.g. overall coverage)</haxe_doc>
		</printReports>
		<finalizeTestClass set="method" line="265">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a test class has completed executing all tests</haxe_doc>
		</finalizeTestClass>
		<updateTestClass set="method" line="256">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called after every test has executed</haxe_doc>
		</updateTestClass>
		<initializeTestClass set="method" line="243">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Called when a new test class is about to execute tests</haxe_doc>
		</initializeTestClass>
		<reportFinalStatistics public="1" set="method" line="222">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<d/>
			</f>
			<haxe_doc>* Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data</haxe_doc>
		</reportFinalStatistics>
		<reportFinalCoverage public="1" set="method" line="201"><f a="?percent:missingCoverageResults:summary:?classBreakdown:?packageBreakdown:?executionFrequency">
	<x path="Float"/>
	<c path="Array"><t path="massive.munit.CoverageResult"/></c>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></reportFinalCoverage>
		<setCurrentTestClassCoverage public="1" set="method" line="194"><f a="result">
	<t path="massive.munit.CoverageResult"/>
	<x path="Void"/>
</f></setCurrentTestClassCoverage>
		<addIgnore public="1" set="method" line="188">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test has been ignored.
	 *
	 * @param	result			an ignored test</haxe_doc>
		</addIgnore>
		<addError public="1" set="method" line="177">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result</haxe_doc>
		</addError>
		<addFail public="1" set="method" line="166">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test fails.
	 *  
	 * @param	result			a failed test result</haxe_doc>
		</addFail>
		<addPass public="1" set="method" line="155">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test passes.
	 *  
	 * @param	result			a passed test result</haxe_doc>
		</addPass>
		<setCurrentTestClass public="1" set="method" line="137">
			<f a="className">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Classed when test class changes
	*
	* @param className		qualified name of current test class</haxe_doc>
		</setCurrentTestClass>
		<init set="method" line="111"><f a=""><x path="Void"/></f></init>
		<finalResult><x path="Bool"/></finalResult>
		<originalTrace><d/></originalTrace>
		<totalCoverageResults><c path="Array"><t path="massive.munit.CoverageResult"/></c></totalCoverageResults>
		<totalCoverageReport><c path="String"/></totalCoverageReport>
		<totalCoveragePercent><x path="Float"/></totalCoveragePercent>
		<totalResults><c path="Array"><c path="massive.munit.TestResult"/></c></totalResults>
		<currentCoverageResult><t path="massive.munit.CoverageResult"/></currentCoverageResult>
		<currentClassResults><c path="Array"><c path="massive.munit.TestResult"/></c></currentClassResults>
		<currentTestClass><c path="String"/></currentTestClass>
		<ignoreCount><x path="Int"/></ignoreCount>
		<errorCount><x path="Int"/></errorCount>
		<failCount><x path="Int"/></failCount>
		<passCount><x path="Int"/></passCount>
		<get_output set="method" line="78"><f a=""><c path="String"/></f></get_output>
		<output public="1" get="accessor" set="null">
			<c path="String"/>
			<meta><m n=":isVar"/></meta>
		</output>
		<set_completionHandler set="method" line="63"><f a="value">
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<x path="Void"/>
	</f>
</f></set_completionHandler>
		<get_completionHandler set="method" line="59"><f a=""><f a="">
	<c path="massive.munit.ITestResultClient"/>
	<x path="Void"/>
</f></f></get_completionHandler>
		<completionHandler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* Handler which if present, is called when the client has completed generating its results.</haxe_doc>
		</completionHandler>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier for the client.</haxe_doc>
		</id>
		<new public="1" set="method" line="106"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="massive.munit.client.HTTPClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/HTTPClient.hx">
		<implements path="massive.munit.IAdvancedTestResultClient"/>
		<queue line="66" static="1"><c path="Array"><c path="massive.munit.client.URLRequest"/></c></queue>
		<responsePending line="67" static="1"><x path="Bool"/></responsePending>
		<dispatchNextRequest set="method" line="238" static="1"><f a=""><x path="Void"/></f></dispatchNextRequest>
		<onError set="method" line="227"><f a="msg">
	<c path="String"/>
	<x path="Void"/>
</f></onError>
		<onData set="method" line="216"><f a="data">
	<c path="String"/>
	<x path="Void"/>
</f></onData>
		<platform set="method" line="204"><f a=""><c path="String"/></f></platform>
		<sendResult set="method" line="184"><f a="result">
	<unknown/>
	<x path="Void"/>
</f></sendResult>
		<reportFinalStatistics public="1" set="method" line="177">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<d/>
			</f>
			<haxe_doc>* Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data if any</haxe_doc>
		</reportFinalStatistics>
		<addIgnore public="1" set="method" line="161">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test has been ignored.
	 *
	 * @param	result			an ignored test</haxe_doc>
		</addIgnore>
		<addError public="1" set="method" line="151">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result</haxe_doc>
		</addError>
		<addFail public="1" set="method" line="141">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test fails.
	 *  
	 * @param	result			a failed test result</haxe_doc>
		</addFail>
		<addPass public="1" set="method" line="131">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test passes.
	 *  
	 * @param	result			a passed test result</haxe_doc>
		</addPass>
		<setCurrentTestClass public="1" set="method" line="118">
			<f a="className">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Classed when test class changes
	*
	* @param className		qualified name of current test class</haxe_doc>
		</setCurrentTestClass>
		<queueRequest><x path="Bool"/></queueRequest>
		<request><c path="massive.munit.client.URLRequest"/></request>
		<url><c path="String"/></url>
		<client><c path="massive.munit.ITestResultClient"/></client>
		<set_completionHandler set="method" line="88"><f a="value">
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<x path="Void"/>
	</f>
</f></set_completionHandler>
		<get_completionHandler set="method" line="84"><f a=""><f a="">
	<c path="massive.munit.ITestResultClient"/>
	<x path="Void"/>
</f></f></get_completionHandler>
		<completionHandler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* Handler which if present, is called when the client has completed sending the test results to the specificied url. 
	 * This will be called once an HTTP response has been recieved.</haxe_doc>
		</completionHandler>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier for the client.</haxe_doc>
		</id>
		<new public="1" set="method" line="105">
			<f a="client:?url:?queueRequest">
				<c path="massive.munit.ITestResultClient"/>
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* 
	 * @param	client				the test result client to decorate
	 * @param	url					the url to send test results to
	 * @param	?queueRequest		[optional] whether to add http requests to a global queue. Default is true.
	 * @param	?httpRequest		[optional] a custom http request to use to dispatch the result.</haxe_doc>
		</new>
		<haxe_doc>* Decorates other ITestResultClient's, adding behavior to post test results to a specified url.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.client.URLRequest" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/HTTPClient.hx" module="massive.munit.client.HTTPClient">
		<internalOnError set="method" line="333"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></internalOnError>
		<internalOnData set="method" line="328"><f a="event">
	<c path="flash.events.Event"/>
	<x path="Void"/>
</f></internalOnData>
		<send public="1" set="method" line="299"><f a=""><x path="Void"/></f></send>
		<setHeader public="1" set="method" line="288"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></setHeader>
		<createClient set="method" line="277"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></createClient>
		<client public="1"><c path="flash.net.URLRequest"/></client>
		<headers><c path="haxe.ds.StringMap"><c path="String"/></c></headers>
		<url><c path="String"/></url>
		<data public="1"><d/></data>
		<onError public="1"><f a="">
	<d/>
	<x path="Void"/>
</f></onError>
		<onData public="1"><f a="">
	<d/>
	<x path="Void"/>
</f></onData>
		<new public="1" set="method" line="270"><f a="url">
	<c path="String"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="massive.munit.client.JUnitReportClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/JUnitReportClient.hx">
		<implements path="massive.munit.IAdvancedTestResultClient"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="46" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<startTestSuite set="method" line="214"><f a=""><x path="Void"/></f></startTestSuite>
		<endTestSuite set="method" line="196"><f a=""><x path="Void"/></f></endTestSuite>
		<reportFinalStatistics public="1" set="method" line="188">
			<f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Float"/>
				<d/>
			</f>
			<haxe_doc>* Called when all tests are complete.
	 *  
	 * @param	testCount		total number of tests run
	 * @param	passCount		total number of tests which passed
	 * @param	failCount		total number of tests which failed
	 * @param	errorCount		total number of tests which were erroneous
	 * @param	ignoreCount		total number of ignored tests
	 * @param	time			number of milliseconds taken for all tests to be executed
	 * @return	collated test result data</haxe_doc>
		</reportFinalStatistics>
		<addIgnore public="1" set="method" line="168">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test has been ignored.
	 *
	 * @param	result			an ignored test</haxe_doc>
		</addIgnore>
		<addError public="1" set="method" line="152">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test triggers an unexpected exception.
	 *  
	 * @param	result			an erroneous test result</haxe_doc>
		</addError>
		<addFail public="1" set="method" line="136">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test fails.
	 *  
	 * @param	result			a failed test result</haxe_doc>
		</addFail>
		<addPass public="1" set="method" line="124">
			<f a="result">
				<c path="massive.munit.TestResult"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Called when a test passes.
	 *  
	 * @param	result			a passed test result</haxe_doc>
		</addPass>
		<setCurrentTestClass public="1" set="method" line="108">
			<f a="className">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Classed when test class changes
	*
	* @param className		qualified name of current test class</haxe_doc>
		</setCurrentTestClass>
		<suiteExecutionTime><x path="Float"/></suiteExecutionTime>
		<suiteErrorCount><x path="Int"/></suiteErrorCount>
		<suiteFailCount><x path="Int"/></suiteFailCount>
		<suitePassCount><x path="Int"/></suitePassCount>
		<currentTestClass><c path="String"/></currentTestClass>
		<testSuiteXML><c path="StringBuf"/></testSuiteXML>
		<xml><c path="StringBuf"/></xml>
		<newline public="1">
			<c path="String"/>
			<haxe_doc><![CDATA[* Newline delimiter. Defaults to '\n'.
	 * 
	 * <p>
	 * Should be set before the client is passed to a test runner.
	 * </p>]]></haxe_doc>
		</newline>
		<set_completionHandler set="method" line="67"><f a="value">
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<x path="Void"/>
	</f>
	<f a="">
		<c path="massive.munit.ITestResultClient"/>
		<x path="Void"/>
	</f>
</f></set_completionHandler>
		<get_completionHandler set="method" line="63"><f a=""><f a="">
	<c path="massive.munit.ITestResultClient"/>
	<x path="Void"/>
</f></f></get_completionHandler>
		<completionHandler public="1" get="accessor" set="accessor">
			<f a="">
				<c path="massive.munit.ITestResultClient"/>
				<x path="Void"/>
			</f>
			<meta><m n=":isVar"/></meta>
			<haxe_doc>* Handler which if present, is called when the client has completed generating its results.</haxe_doc>
		</completionHandler>
		<id public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The unique identifier for the client.</haxe_doc>
		</id>
		<new public="1" set="method" line="92">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Class constructor.</haxe_doc>
		</new>
		<haxe_doc>* Generates xml formatted tests results compliant for processing by the JUnitReport 
 * Apache Ant task (http://ant.apache.org/manual/Tasks/junitreport.html).
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.client.PrintClientBase" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/PrintClientBase.hx">
		<extends path="massive.munit.client.AbstractTestResultClient"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="43" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<indentString set="method" line="262"><f a="value:?indent">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
</f></indentString>
		<printLine public="1" set="method" line="255"><f a="value:?indent">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></printLine>
		<print public="1" set="method" line="250"><f a="value">
	<d/>
	<x path="Void"/>
</f></print>
		<printOverallResult set="method" line="244" override="1"><f a="result">
	<x path="Bool"/>
	<x path="Void"/>
</f></printOverallResult>
		<printFinalStatistics set="method" line="229" override="1"><f a="result:testCount:passCount:failCount:errorCount:ignoreCount:time">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></printFinalStatistics>
		<filterIngored set="method" line="224"><f a="result">
	<c path="massive.munit.TestResult"/>
	<x path="Bool"/>
</f></filterIngored>
		<printFinalIgnoredStatistics set="method" line="203"><f a="count">
	<x path="Int"/>
	<x path="Void"/>
</f></printFinalIgnoredStatistics>
		<printReports set="method" line="198" override="1"><f a=""><x path="Void"/></f></printReports>
		<printIndentedLines set="method" line="188"><f a="value:?indent">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></printIndentedLines>
		<reportFinalCoverage public="1" set="method" line="137" override="1"><f a="?percent:missingCoverageResults:summary:?classBreakdown:?packageBreakdown:?executionFrequency">
	<x path="Float"/>
	<c path="Array"><t path="massive.munit.CoverageResult"/></c>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></reportFinalCoverage>
		<setCurrentTestClassCoverage public="1" set="method" line="121" override="1"><f a="result">
	<t path="massive.munit.CoverageResult"/>
	<x path="Void"/>
</f></setCurrentTestClassCoverage>
		<finalizeTestClass set="method" line="94" override="1"><f a=""><x path="Void"/></f></finalizeTestClass>
		<updateTestClass set="method" line="77" override="1"><f a="result">
	<c path="massive.munit.TestResult"/>
	<x path="Void"/>
</f></updateTestClass>
		<initializeTestClass set="method" line="71" override="1"><f a=""><x path="Void"/></f></initializeTestClass>
		<init set="method" line="62" override="1"><f a=""><x path="Void"/></f></init>
		<divider2><c path="String"/></divider2>
		<divider><c path="String"/></divider>
		<includeIgnoredReport><x path="Bool"/></includeIgnoredReport>
		<verbose public="1"><x path="Bool"/></verbose>
		<new public="1" set="method" line="51"><f a="?includeIgnoredReport">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="massive.munit.client.PrintClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/PrintClient.hx">
		<extends path="massive.munit.client.PrintClientBase"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="65" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<printLine public="1" set="method" line="193" override="1"><f a="value:?indent">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></printLine>
		<print public="1" set="method" line="173" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></print>
		<reportFinalStatistics public="1" set="method" line="168" override="1"><f a="testCount:passCount:failCount:errorCount:ignoreCount:time">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<d/>
</f></reportFinalStatistics>
		<customTrace set="method" line="161"><f a="value:?info">
	<unknown/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></customTrace>
		<printOverallResult set="method" line="149" override="1"><f a="result">
	<x path="Bool"/>
	<x path="Void"/>
</f></printOverallResult>
		<initFlash set="method" line="102"><f a=""><x path="Void"/></f></initFlash>
		<init set="method" line="84" override="1"><f a=""><x path="Void"/></f></init>
		<textField><c path="flash.text.TextField"/></textField>
		<external><c path="massive.munit.client.ExternalPrintClient"/></external>
		<new public="1" set="method" line="78"><f a="?includeIgnoredReport">
	<x path="Bool"/>
	<x path="Void"/>
</f></new>
		<haxe_doc><![CDATA[* Generates basic text formatted test result output.
 * 
 * <p>
 * Example output:
 * </p>
 * <pre>
 * MUnit Results
 * ------------------------------
 * 
 * Class: SampleTest ...
 * Class: sub.ItemTest ..
 * 
 * PASSED
 * Tests: 5  Passed: 5  Failed: 0 Errors: 0 Ignored: 0 Time: 0.202
 * ==============================
 * </pre>
 * 
 * @author Mike Stead]]></haxe_doc>
	</class>
	<class path="massive.munit.client.ExternalPrintClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/PrintClientBase.hx" module="massive.munit.client.PrintClientBase" interface="1">
		<printSummary public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></printSummary>
		<addCoverageSummary public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addCoverageSummary>
		<addCoverageReportSection public="1" set="method"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></addCoverageReportSection>
		<addMissingCoverageClass public="1" set="method"><f a="className:?percent">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addMissingCoverageClass>
		<createCoverageReport public="1" set="method"><f a="?percent">
	<x path="Float"/>
	<x path="Void"/>
</f></createCoverageReport>
		<addTestClassCoverageItem public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestClassCoverageItem>
		<addTestClassCoverage public="1" set="method"><f a="className:?percent">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addTestClassCoverage>
		<addTestIgnore public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestIgnore>
		<addTestError public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestError>
		<addTestFail public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestFail>
		<addTestPass public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestPass>
		<trace public="1" set="method"><f a="value">
	<d/>
	<x path="Void"/>
</f></trace>
		<setTestClassResult public="1" set="method"><f a="resultType">
	<x path="Int"/>
	<x path="Void"/>
</f></setTestClassResult>
		<printToTestClassSummary public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></printToTestClassSummary>
		<createTestClass public="1" set="method"><f a="className">
	<c path="String"/>
	<x path="Void"/>
</f></createTestClass>
		<setResultBackground public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setResultBackground>
		<printLine public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></printLine>
		<print public="1" set="method"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></print>
		<setResult public="1" set="method"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setResult>
		<queue public="1" set="method"><f a="methodName:?args">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
</f></queue>
	</class>
	<class path="massive.munit.client.ExternalPrintClientJS" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/PrintClientBase.hx" module="massive.munit.client.PrintClientBase">
		<implements path="massive.munit.client.ExternalPrintClient"/>
		<externalInterfaceQueue line="357" static="1"><c path="Array"><c path="String"/></c></externalInterfaceQueue>
		<flashInitialised line="358" static="1"><x path="Bool"/></flashInitialised>
		<externalInterfaceCounter line="359" static="1"><x path="Int"/></externalInterfaceCounter>
		<EXTERNAL_INTERFACE_FRAME_DELAY line="360" static="1"><x path="Int"/></EXTERNAL_INTERFACE_FRAME_DELAY>
		<enterFrameHandler set="method" line="362" static="1"><f a="event">
	<d/>
	<x path="Void"/>
</f></enterFrameHandler>
		<serialiseToHTML public="1" set="method" line="544"><f a="value">
	<d/>
	<c path="String"/>
</f></serialiseToHTML>
		<convertToJavaScript public="1" set="method" line="516"><f a="method:?args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<c path="String"/>
</f></convertToJavaScript>
		<queue public="1" set="method" line="486"><f a="method:?args">
	<c path="String"/>
	<d/>
	<x path="Bool"/>
</f></queue>
		<printSummary public="1" set="method" line="479"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></printSummary>
		<addCoverageSummary public="1" set="method" line="471"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addCoverageSummary>
		<addCoverageReportSection public="1" set="method" line="466"><f a="name:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></addCoverageReportSection>
		<addMissingCoverageClass public="1" set="method" line="461"><f a="className:?percent">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addMissingCoverageClass>
		<createCoverageReport public="1" set="method" line="456"><f a="?percent">
	<x path="Float"/>
	<x path="Void"/>
</f></createCoverageReport>
		<addTestClassCoverageItem public="1" set="method" line="449"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestClassCoverageItem>
		<addTestClassCoverage public="1" set="method" line="444"><f a="className:?percent">
	<c path="String"/>
	<x path="Float"/>
	<x path="Void"/>
</f></addTestClassCoverage>
		<addTestIgnore public="1" set="method" line="439"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestIgnore>
		<addTestError public="1" set="method" line="434"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestError>
		<addTestFail public="1" set="method" line="429"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestFail>
		<addTestPass public="1" set="method" line="423"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></addTestPass>
		<setTestClassResult public="1" set="method" line="418"><f a="resultType">
	<x path="Int"/>
	<x path="Void"/>
</f></setTestClassResult>
		<printToTestClassSummary public="1" set="method" line="413"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></printToTestClassSummary>
		<createTestClass public="1" set="method" line="408"><f a="className">
	<c path="String"/>
	<x path="Void"/>
</f></createTestClass>
		<trace public="1" set="method" line="403"><f a="value">
	<d/>
	<x path="Void"/>
</f></trace>
		<setResultBackground public="1" set="method" line="396"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setResultBackground>
		<setResult public="1" set="method" line="391"><f a="value">
	<x path="Bool"/>
	<x path="Void"/>
</f></setResult>
		<printLine public="1" set="method" line="386"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></printLine>
		<print public="1" set="method" line="381"><f a="value">
	<c path="String"/>
	<x path="Void"/>
</f></print>
		<new public="1" set="method" line="313"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="massive.munit.client.RichPrintClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/RichPrintClient.hx">
		<extends path="massive.munit.client.PrintClientBase"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="44" static="1">
			<c path="String"/>
			<haxe_doc>* Default id of this client.</haxe_doc>
		</DEFAULT_ID>
		<printLine public="1" set="method" line="297" override="1"><f a="value:?indent">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></printLine>
		<print public="1" set="method" line="285" override="1"><f a="value">
	<d/>
	<x path="Void"/>
</f></print>
		<customTrace set="method" line="274"><f a="value:?info">
	<unknown/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></customTrace>
		<printOverallResult set="method" line="268" override="1"><f a="result">
	<x path="Bool"/>
	<x path="Void"/>
</f></printOverallResult>
		<printFinalStatistics set="method" line="253" override="1"><f a="result:testCount:passCount:failCount:errorCount:ignoreCount:time">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></printFinalStatistics>
		<printReports set="method" line="248" override="1"><f a=""><x path="Void"/></f></printReports>
		<printMissingCoverage set="method" line="234"><f a="missingCoverageResults">
	<c path="Array"><t path="massive.munit.CoverageResult"/></c>
	<x path="Void"/>
</f></printMissingCoverage>
		<trim set="method" line="218"><f a="output">
	<c path="String"/>
	<c path="String"/>
</f></trim>
		<reportFinalCoverage public="1" set="method" line="186" override="1"><f a="?percent:missingCoverageResults:summary:?classBreakdown:?packageBreakdown:?executionFrequency">
	<x path="Float"/>
	<c path="Array"><t path="massive.munit.CoverageResult"/></c>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></reportFinalCoverage>
		<setCurrentTestClassCoverage public="1" set="method" line="170" override="1"><f a="result">
	<t path="massive.munit.CoverageResult"/>
	<x path="Void"/>
</f></setCurrentTestClassCoverage>
		<getTestClassResultType set="method" line="161"><f a=""><e path="massive.munit.TestResultType"/></f></getTestClassResultType>
		<finalizeTestClass set="method" line="140" override="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* summarises result for currently executing test class
	* and update visual state of test class</haxe_doc>
		</finalizeTestClass>
		<serializeTestResult set="method" line="104"><f a="result">
	<c path="massive.munit.TestResult"/>
	<c path="String"/>
</f></serializeTestResult>
		<updateTestClass set="method" line="73" override="1"><f a="result">
	<c path="massive.munit.TestResult"/>
	<x path="Void"/>
</f></updateTestClass>
		<initializeTestClass set="method" line="66" override="1"><f a=""><x path="Void"/></f></initializeTestClass>
		<init set="method" line="55" override="1"><f a=""><x path="Void"/></f></init>
		<external><c path="massive.munit.client.ExternalPrintClient"/></external>
		<testClassResultType><e path="massive.munit.TestResultType"/></testClassResultType>
		<new public="1" set="method" line="49"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="massive.munit.client.SummaryReportClient" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/client/SummaryReportClient.hx">
		<extends path="massive.munit.client.AbstractTestResultClient"/>
		<DEFAULT_ID public="1" get="inline" set="null" line="59" static="1"><c path="String"/></DEFAULT_ID>
		<printReports set="method" line="106" override="1"><f a=""><x path="Void"/></f></printReports>
		<printOverallResult set="method" line="100" override="1"><f a="result">
	<x path="Bool"/>
	<x path="Void"/>
</f></printOverallResult>
		<printFinalStatistics set="method" line="67" override="1"><f a="result:testCount:passCount:failCount:errorCount:ignoreCount:time">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></printFinalStatistics>
		<new public="1" set="method" line="61"><f a=""><x path="Void"/></f></new>
		<haxe_doc>Provides a high level summary report in text format

e.g.

result:true
count:49
count:7
pass:5
fail:2
error:0
ignore:2
time:1234.3

# className#method
# className#method
# className#method
# className#method
# className#method
# className#method
# className#method
# className#method
# className#method
# ... plus 5 more</haxe_doc>
	</class>
	<class path="massive.munit.util.MathUtil" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/util/MathUtil.hx">
		<round public="1" set="method" line="48" static="1">
			<f a="value:precision">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Round a floating point number to a given decimal place.
	 * 
	 * @param	value			number to round up
	 * @param	precision		precision to round the value to
	 * @return	the rounded value</haxe_doc>
		</round>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Utility class for math related operations.
 * 
 * @author Mike Stead</haxe_doc>
	</class>
	<class path="massive.munit.util.Timer" params="" file="/usr/lib/haxe/lib/munit/2,0,2/massive/munit/util/Timer.hx">
		<delay public="1" set="method" line="145" static="1"><f a="f:time_ms">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
	<c path="massive.munit.util.Timer"/>
</f></delay>
		<stamp public="1" set="method" line="160" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>*	Returns a timestamp, in seconds</haxe_doc>
		</stamp>
		<run public="1" set="dynamic" line="120"><f a=""><x path="Void"/></f></run>
		<stop public="1" set="method" line="94"><f a=""><x path="Void"/></f></stop>
		<id><t path="Null"><x path="Int"/></t></id>
		<new public="1" set="method" line="76"><f a="time_ms">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":expose"><e>"massive.munit.util.Timer"</e></m></meta>
	</class>
	<class path="org.hamcrest.Exception" params="" file="/usr/lib/haxe/lib/hamcrest/1,2,1/org/hamcrest/Exception.hx">
		<toString public="1" set="method" line="30"><f a=""><c path="String"/></f></toString>
		<info public="1" set="null"><t path="haxe.PosInfos"/></info>
		<get_cause set="method" line="17"><f a=""><d/></f></get_cause>
		<cause public="1" get="accessor" set="null"><d/></cause>
		<get_message set="method" line="14"><f a=""><c path="String"/></f></get_message>
		<message public="1" get="accessor" set="null"><c path="String"/></message>
		<get_name set="method" line="11"><f a=""><c path="String"/></f></get_name>
		<name public="1" get="accessor" set="null"><c path="String"/></name>
		<new public="1" set="method" line="21"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="org.hamcrest.AssertionException" params="" file="/usr/lib/haxe/lib/hamcrest/1,2,1/org/hamcrest/AssertionException.hx">
		<extends path="org.hamcrest.Exception"/>
		<new public="1" set="method" line="10"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="org.hamcrest.IllegalArgumentException" params="" file="/usr/lib/haxe/lib/hamcrest/1,2,1/org/hamcrest/Exception.hx" module="org.hamcrest.Exception">
		<extends path="org.hamcrest.Exception"/>
		<new public="1" set="method" line="43"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="org.hamcrest.MissingImplementationException" params="" file="/usr/lib/haxe/lib/hamcrest/1,2,1/org/hamcrest/Exception.hx" module="org.hamcrest.Exception">
		<extends path="org.hamcrest.Exception"/>
		<new public="1" set="method" line="51"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="org.hamcrest.UnsupportedOperationException" params="" file="/usr/lib/haxe/lib/hamcrest/1,2,1/org/hamcrest/Exception.hx" module="org.hamcrest.Exception">
		<extends path="org.hamcrest.Exception"/>
		<new public="1" set="method" line="59"><f a="?message:?cause:?info">
	<c path="String"/>
	<d/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></new>
	</class>
</haxe>